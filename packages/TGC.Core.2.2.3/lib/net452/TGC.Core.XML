<?xml version="1.0"?>
<doc>
    <assembly>
        <name>TGC.Core</name>
    </assembly>
    <members>
        <member name="T:TGC.Core.Text.TgcText2D.TextAlign">
            <summary>
                Alternativas de alineación del texto
            </summary>
        </member>
        <member name="P:TGC.Core.Text.TgcText2D.D3dFont">
            <summary>
                Fuente de Direct3D para la letra del texto
            </summary>
        </member>
        <member name="P:TGC.Core.Text.TgcText2D.Color">
            <summary>
                Color del texto
            </summary>
        </member>
        <member name="P:TGC.Core.Text.TgcText2D.Position">
            <summary>
                Posicion del texto
            </summary>
        </member>
        <member name="P:TGC.Core.Text.TgcText2D.Size">
            <summary>
                Tamaño maximo del recuadro del texto
            </summary>
        </member>
        <member name="P:TGC.Core.Text.TgcText2D.Text">
            <summary>
                Texto a renderizar
            </summary>
        </member>
        <member name="P:TGC.Core.Text.TgcText2D.Format">
            <summary>
                Formato de renderizado del texto.
                Si se cambia a mano el formato, no se respeta la alineacion del texto que se haya configurado.
            </summary>
        </member>
        <member name="P:TGC.Core.Text.TgcText2D.Align">
            <summary>
                Alineación del texto
            </summary>
        </member>
        <member name="M:TGC.Core.Text.TgcText2D.changeFont(System.Drawing.Font)">
            <summary>
                Cambia la fuente del texto
            </summary>
            <param name="font">Fuente del sistema</param>
        </member>
        <member name="M:TGC.Core.Text.TgcText2D.changeTextAlign(TGC.Core.Text.TgcText2D.TextAlign)">
            <summary>
                Cambiar TextAlign y configurar DrawTextFormat
            </summary>
        </member>
        <member name="M:TGC.Core.Text.TgcText2D.drawText(System.String,System.Int32,System.Int32,System.Drawing.Color)">
            <summary>
                Dibujar un texto en la posición indicada, con el color indicado.
                Utilizar la fuente default del Framework.
            </summary>
            <param name="text">Texto a dibujar</param>
            <param name="x">Posición X de la pantalla</param>
            <param name="y">Posición Y de la pantalla</param>
            <param name="color">Color del texto</param>
        </member>
        <member name="T:TGC.Core.Camara.TgcCamera">
            <summary>
                Clase camara estatica, default del Framework.
            </summary>
        </member>
        <member name="P:TGC.Core.Camara.TgcCamera.Position">
            <summary>
                Posicion de la camara
            </summary>
        </member>
        <member name="P:TGC.Core.Camara.TgcCamera.LookAt">
            <summary>
                Posición del punto al que mira la cámara
            </summary>
        </member>
        <member name="P:TGC.Core.Camara.TgcCamera.UpVector">
            <summary>
                Vector direccional hacia arriba (puede diferir si la camara se invierte).
            </summary>
        </member>
        <member name="M:TGC.Core.Camara.TgcCamera.SetCamera(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Configura la posicion de la camara, punto de entrada para todas las camaras, con los mismos se calcula la matriz de view.
                Los vectores son utilizadas por GetViewMatrix.
            </summary>
            <param name="pos">Posicion de la camara</param>
            <param name="lookAt">Punto hacia el cual se quiere ver</param>
        </member>
        <member name="M:TGC.Core.Camara.TgcCamera.SetCamera(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Configura la posicion de la camara, punto de entrada para todas las camaras, con los mismos se calcula la matriz de view.
                Los vectores son utilizadas por GetViewMatrix.
            </summary>
            <param name="pos">Posicion de la camara</param>
            <param name="lookAt">Punto hacia el cual se quiere ver</param>
            <param name="upVector">Vector direccion hacia arriba</param>
        </member>
        <member name="M:TGC.Core.Camara.TgcCamera.UpdateCamera(System.Single)">
            <summary>
                Permite actualizar el estado interno de la camara si se sobrescribe este metodo. por defecto no realiza ninguna accion.
                Si se realiza procesamiento interno se puede invocar al metodo SetCamera para actualizar posicion, lookAt y upVector.
            </summary>
        </member>
        <member name="M:TGC.Core.Camara.TgcCamera.GetViewMatrix">
            <summary>
                Devuelve la matriz View en base a los valores de la camara. Es invocado en cada update de render.
            </summary>
        </member>
        <member name="M:TGC.Core.Direct3D.D3DDevice.#ctor">
            <summary>
                Constructor privado para poder hacer el singleton
            </summary>
        </member>
        <member name="P:TGC.Core.Direct3D.D3DDevice.Device">
            <summary>
                Device de DirectX 3D para crear primitivas
            </summary>
        </member>
        <member name="M:TGC.Core.Direct3D.D3DDevice.DefaultValues">
            <summary>
                Valores default del Direct3d Device
            </summary>
        </member>
        <member name="M:TGC.Core.Direct3D.D3DDevice.EnableParticles">
            <summary>
                habilita los points sprites.
                Estaba este comentario antes, asi que lo dejo con default false.
                INEXPLICABLE PERO ESTO HACE QUE MI NOTEBOOK SE CUELGUE CON LA PANTALLA EN NEGRO!!!!!!!!!!
            </summary>
        </member>
        <member name="P:TGC.Core.Example.TgcExample.ElapsedTime">
            <summary>
                Tiempo en segundos transcurridos desde el ultimo frame.
            </summary>
        </member>
        <member name="P:TGC.Core.Example.TgcExample.FPS">
            <summary>
                Activa o desactiva el contador de frames por segundo.
            </summary>
        </member>
        <member name="P:TGC.Core.Example.TgcExample.AxisLinesEnable">
            <summary>
                Habilita/Deshabilita el dibujado de los ejes cartesianos
            </summary>
        </member>
        <member name="P:TGC.Core.Example.TgcExample.AxisLines">
            <summary>
                Utilidad para visualizar los ejes cartesianos
            </summary>
        </member>
        <member name="P:TGC.Core.Example.TgcExample.Category">
            <summary>
                Categoria a la que pertenece el ejemplo.
                Influye en donde se va a haber en el arbol de la derecha de la pantalla.
            </summary>
        </member>
        <member name="P:TGC.Core.Example.TgcExample.Name">
            <summary>
                Completar nombre del grupo en formato Grupo NN
            </summary>
        </member>
        <member name="P:TGC.Core.Example.TgcExample.Description">
            <summary>
                Completar con la descripcion del TP
            </summary>
        </member>
        <member name="P:TGC.Core.Example.TgcExample.MediaDir">
            <summary>
                Path de la carpeta Media que contiene todo el contenido visual de los ejemplos, como texturas, modelos 3D, etc.
            </summary>
        </member>
        <member name="P:TGC.Core.Example.TgcExample.ShadersDir">
            <summary>
                Path de la carpeta Shaders que contiene todo los shaders genericos
            </summary>
        </member>
        <member name="P:TGC.Core.Example.TgcExample.Camara">
            <summary>
                Camara que esta utilizando el ejemplo
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.Init">
            <summary>
                Se llama cuando el ejemplo es elegido para ejecutar.
                Inicializar todos los recursos y configuraciones que se van a utilizar.
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.Update">
            <summary>
                Update de mi modelo.
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.Render">
            <summary>
                Se llama para renderizar cada cuadro del ejemplo.
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.PreUpdate">
            <summary>
                Metodos a ejecutar antes del update.
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.PreRender">
            <summary>
                Metodos a ejecutar antes del render.
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.PostRender">
            <summary>
                Metodos a ejecutar cuando termino el render.
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.UpdateClock">
            <summary>
                Actualiza el elapsedTime, importante invocar en cada update loop.
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.UpdateInput">
            <summary>
                Acutaliza el input
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.UpdateView">
            <summary>
                Actualiza la Camara
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.UpdateFrustum">
            <summary>
                Acutaliza el Frustum
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.UpdateSounds3D">
            <summary>
                Actualiza el Listener3D
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.BeginRenderScene">
            <summary>
                Limpia la pantalla y inicia la escena 3D
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.BeginScene">
            <summary>
                Inicia la escena 3D
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.ClearTextures">
            <summary>
                Limpia las texturas
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.RenderAxis">
            <summary>
                Dibuja el indicador de los ejes cartesianos
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.RenderFPS">
            <summary>
                Dibuja el contador de FPS si esta activo
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.EndRenderScene">
            <summary>
                Finaliza y presenta (se debe hacer al final del render) la escena 3D
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.EndScene">
            <summary>
                Finaliza una escena que se inicio con un BeginScene()
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.Dispose">
            <summary>
                Se llama cuando el ejemplo es cerrado.
                Liberar todos los recursos utilizados. OBLIGATORIAMENTE!!!!
            </summary>
        </member>
        <member name="M:TGC.Core.Example.TgcExample.ResetDefaultConfig">
            <summary>
                Vuelve la configuracion de Render y otras cosas a la configuracion inicial
            </summary>
        </member>
        <member name="T:TGC.Core.Fog.TgcFog">
            <summary>
                Herramienta para manipular el efecto de Niebla provisto por Direct3D
            </summary>
        </member>
        <member name="P:TGC.Core.Fog.TgcFog.StartDistance">
            <summary>
                Distancia desde la que comienza a haber niebla
            </summary>
        </member>
        <member name="P:TGC.Core.Fog.TgcFog.EndDistance">
            <summary>
                Distancia hasta la que llega la niebla
            </summary>
        </member>
        <member name="P:TGC.Core.Fog.TgcFog.Density">
            <summary>
                Densidad del efecto
            </summary>
        </member>
        <member name="P:TGC.Core.Fog.TgcFog.Enabled">
            <summary>
                Habilita o deshabilita el efecto de niebla.
                Es necesario llamar a updateValues() para que realmente se aplica el efecto.
            </summary>
        </member>
        <member name="P:TGC.Core.Fog.TgcFog.Color">
            <summary>
                Color de la niebla
            </summary>
        </member>
        <member name="M:TGC.Core.Fog.TgcFog.resetValues">
            <summary>
                Configura los valores iniciales del efecto
            </summary>
        </member>
        <member name="M:TGC.Core.Fog.TgcFog.updateValues">
            <summary>
                Actualiza todos los valores de la niebla.
                Activa o desactiva efectivamente el efecto, según como se haya configurado.
            </summary>
        </member>
        <member name="T:TGC.Core.Geometry.TgcArrow">
            <summary>
                Herramienta para dibujar una flecha 3D.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcArrow.PStart">
            <summary>
                Punto de inicio de la linea
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcArrow.PEnd">
            <summary>
                Punto final de la linea
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcArrow.BodyColor">
            <summary>
                Color del cuerpo de la flecha
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcArrow.HeadColor">
            <summary>
                Color de la cabeza de la flecha
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcArrow.Enabled">
            <summary>
                Indica si la flecha esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcArrow.Thickness">
            <summary>
                Grosor del cuerpo de la flecha. Debe ser mayor a cero.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcArrow.HeadSize">
            <summary>
                Tamaño de la cabeza de la flecha. Debe ser mayor a cero.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcArrow.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcArrow.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcArrow.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcArrow.render">
            <summary>
                Renderizar la flecha
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcArrow.dispose">
            <summary>
                Liberar recursos de la flecha
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcArrow.updateValues">
            <summary>
                Actualizar parámetros de la flecha en base a los valores configurados
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcArrow.fromExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una flecha en base a sus puntos extremos
            </summary>
            <param name="start">Punto de inicio</param>
            <param name="end">Punto de fin</param>
            <returns>Flecha creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcArrow.fromExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Drawing.Color,System.Drawing.Color,System.Single,Microsoft.DirectX.Vector2)">
            <summary>
                Crea una flecha en base a sus puntos extremos, con el color y el grosor especificado
            </summary>
            <param name="start">Punto de inicio</param>
            <param name="end">Punto de fin</param>
            <param name="bodyColor">Color del cuerpo de la flecha</param>
            <param name="headColor">Color de la punta de la flecha</param>
            <param name="thickness">Grosor del cuerpo de la flecha</param>
            <param name="headSize">Tamaño de la punta de la flecha</param>
            <returns>Flecha creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcArrow.fromDirection(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una flecha en base a su punto de inicio y dirección
            </summary>
            <param name="start">Punto de inicio</param>
            <param name="direction">Dirección de la flecha</param>
            <returns>Flecha creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcArrow.fromDirection(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Drawing.Color,System.Drawing.Color,System.Single,Microsoft.DirectX.Vector2)">
            <summary>
                Crea una flecha en base a su punto de inicio y dirección, con el color y el grosor especificado
            </summary>
            <param name="start">Punto de inicio</param>
            <param name="direction">Dirección de la flecha</param>
            <param name="bodyColor">Color del cuerpo de la flecha</param>
            <param name="headColor">Color de la punta de la flecha</param>
            <param name="thickness">Grosor del cuerpo de la flecha</param>
            <param name="headSize">Tamaño de la punta de la flecha</param>
            <returns>Flecha creada</returns>
        </member>
        <member name="T:TGC.Core.Geometry.TgcBox">
            <summary>
                Herramienta para crear una Caja 3D de tamaño variable, con color y Textura
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.#ctor">
            <summary>
                Crea una caja vacia
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.Size">
            <summary>
                Dimensiones de la caja
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.Color">
            <summary>
                Color de los vértices de la caja
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.Texture">
            <summary>
                Textura de la caja
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.Enabled">
            <summary>
                Indica si la caja esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.BoundingBox">
            <summary>
                BoundingBox de la caja
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.UVOffset">
            <summary>
                Offset UV de textura
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.UVTiling">
            <summary>
                Tiling UV de textura
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.render">
            <summary>
                Renderizar la caja
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.dispose">
            <summary>
                Liberar los recursos de la cja
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.Scale">
            <summary>
                Escala de la caja. Siempre es (1, 1, 1).
                Utilizar Size
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.Transform">
            <summary>
                Matriz final que se utiliza para aplicar transformaciones a la malla.
                Si la propiedad AutoTransformEnable esta en True, la matriz se reconstruye en cada cuadro
                en base a los valores de: Position, Rotation, Scale.
                Si AutoTransformEnable está en False, se respeta el valor que el usuario haya cargado en la matriz.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.AutoTransformEnable">
            <summary>
                En True hace que la matriz de transformacion (Transform) de la malla se actualiza en
                cada cuadro en forma automática, según los valores de: Position, Rotation, Scale.
                En False se respeta lo que el usuario haya cargado a mano en la matriz.
                Por default está en False.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.Position">
            <summary>
                Posicion absoluta del centro de la caja
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBox.Rotation">
            <summary>
                Rotación absoluta de la caja
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.move(Microsoft.DirectX.Vector3)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.move(System.Single,System.Single,System.Single)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.moveOrientedY(System.Single)">
            <summary>
                Mueve la malla en base a la orientacion actual de rotacion.
                Es necesario rotar la malla primero
            </summary>
            <param name="movement">Desplazamiento. Puede ser positivo (hacia adelante) o negativo (hacia atras)</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.getPosition(Microsoft.DirectX.Vector3)">
            <summary>
                Obtiene la posicion absoluta de la malla, recibiendo un vector ya creado para
                almacenar el resultado
            </summary>
            <param name="pos">Vector ya creado en el que se carga el resultado</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.rotateX(System.Single)">
            <summary>
                Rota la malla respecto del eje X
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.rotateY(System.Single)">
            <summary>
                Rota la malla respecto del eje Y
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.rotateZ(System.Single)">
            <summary>
                Rota la malla respecto del eje Z
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.updateValues">
            <summary>
                Actualiza la caja en base a los valores configurados
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.setTexture(TGC.Core.Textures.TgcTexture)">
            <summary>
                Configurar textura de la pared
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.activateAlphaBlend">
            <summary>
                Activar AlphaBlending, si corresponde
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.resetAlphaBlend">
            <summary>
                Desactivar AlphaBlending
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.setPositionSize(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Configurar valores de posicion y tamaño en forma conjunta
            </summary>
            <param name="position">Centro de la caja</param>
            <param name="size">Tamaño de la caja</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.setExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Configurar punto mínimo y máximo del box
            </summary>
            <param name="min">Min</param>
            <param name="max">Max</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.updateBoundingBox">
            <summary>
                Actualiza el BoundingBox de la caja.
                No contempla rotacion
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.toMesh(System.String)">
            <summary>
                Convierte el box en un TgcMesh
            </summary>
            <param name="meshName">Nombre de la malla que se va a crear</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.clone">
            <summary>
                Crear un nuevo TgcBox igual a este
            </summary>
            <returns>Box clonado</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.fromSize(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una caja con el centro y tamaño especificado
            </summary>
            <param name="center">Centro de la caja</param>
            <param name="size">Tamaño de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.fromSize(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Drawing.Color)">
            <summary>
                Crea una caja con el centro y tamaño especificado, con el color especificado
            </summary>
            <param name="center">Centro de la caja</param>
            <param name="size">Tamaño de la caja</param>
            <param name="color">Color de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.fromSize(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,TGC.Core.Textures.TgcTexture)">
            <summary>
                Crea una caja con el centro y tamaño especificado, con la textura especificada
            </summary>
            <param name="center">Centro de la caja</param>
            <param name="size">Tamaño de la caja</param>
            <param name="texture">Textura de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.fromSize(Microsoft.DirectX.Vector3)">
            <summary>
                Crea una caja con centro (0,0,0) y el tamaño especificado
            </summary>
            <param name="size">Tamaño de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.fromSize(Microsoft.DirectX.Vector3,System.Drawing.Color)">
            <summary>
                Crea una caja con centro (0,0,0) y el tamaño especificado, con el color especificado
            </summary>
            <param name="size">Tamaño de la caja</param>
            <param name="color">Color de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.fromSize(Microsoft.DirectX.Vector3,TGC.Core.Textures.TgcTexture)">
            <summary>
                Crea una caja con centro (0,0,0) y el tamaño especificado, con la textura especificada
            </summary>
            <param name="size">Tamaño de la caja</param>
            <param name="texture">Textura de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.fromExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una caja en base al punto minimo y maximo
            </summary>
            <param name="pMin">Punto mínimo</param>
            <param name="pMax">Punto máximo</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.fromExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Drawing.Color)">
            <summary>
                Crea una caja en base al punto minimo y maximo, con el color especificado
            </summary>
            <param name="pMin">Punto mínimo</param>
            <param name="pMax">Punto máximo</param>
            <param name="color">Color de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBox.fromExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,TGC.Core.Textures.TgcTexture)">
            <summary>
                Crea una caja en base al punto minimo y maximo, con el color especificado
            </summary>
            <param name="pMin">Punto mínimo</param>
            <param name="pMax">Punto máximo</param>
            <param name="texture">Textura de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="T:TGC.Core.Geometry.TgcConvexPolygon">
            <summary>
                Representa un polígono convexo plano en 3D de una sola cara, compuesto
                por varios vértices que lo delimitan.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcConvexPolygon.BoundingVertices">
            <summary>
                Vertices que definen el contorno polígono.
                Están dados en clockwise-order.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcConvexPolygon.Enabled">
            <summary>
                Indica si la flecha esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcConvexPolygon.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcConvexPolygon.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcConvexPolygon.updateValues">
            <summary>
                Actualizar valores de renderizado.
                Hay que llamarlo al menos una vez para poder hacer Render()
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcConvexPolygon.render">
            <summary>
                Renderizar el polígono
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcConvexPolygon.dispose">
            <summary>
                Liberar recursos del polígono
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcConvexPolygon.Color">
            <summary>
                Color del polígono
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcConvexPolygon.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="T:TGC.Core.Geometry.TgcConvexPolyhedron">
            <summary>
                Representa un volúmen de un cuerpo convexo 3D, delimitado por planos.
                Las normales de los planos apuntan hacia adentro.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcConvexPolyhedron.Planes">
            <summary>
                Planos que definen el cuerpo convexo.
                Apuntan hacia adentro del cuerpo
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcConvexPolyhedron.BoundingVertices">
            <summary>
                Vertices que definen el contorno del cuerpo convexo
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcCylinder.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcCylinder.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcCylinder.UseTexture">
            <summary>
                Habilita el dibujado de la textura
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcCylinder.Length">
            <summary>
                Largo o altura del cilindro
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcCylinder.TopRadius">
            <summary>
                Radio de la tapa superior
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcCylinder.BottomRadius">
            <summary>
                Radio de la tapa inferior
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcCylinder.Radius">
            <summary>
                Radio del cilindro
                Si se usa este setter, tanto el radio superior como el inferior quedan igualados
                Si se usa este getter, se devuelve el radio maximo del cilindro
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcCylinder.Center">
            <summary>
                Centro del cilindro
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcCylinder.setTexture(TGC.Core.Textures.TgcTexture)">
            <summary>
                Setea la textura
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcCylinder.updateValues">
            <summary>
                Actualiza la posicion e inclinacion del cilindro
            </summary>
        </member>
        <member name="T:TGC.Core.Geometry.TgcBoxDebug">
            <summary>
                Herramienta para dibujar una caja 3D que muestra solo sus aristas, con grosor configurable.
            </summary>
        </member>
        <member name="F:TGC.Core.Geometry.TgcBoxDebug.LINE_VERTICES_COUNT">
            <summary>
                Cantidad de vertices total de la caja
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBoxDebug.PMin">
            <summary>
                Punto mínimo de la caja
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBoxDebug.PMax">
            <summary>
                Punto máximo de la caja
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBoxDebug.Color">
            <summary>
                Color de la caja
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBoxDebug.Enabled">
            <summary>
                Indica si la caja esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBoxDebug.Thickness">
            <summary>
                Grosor de la caja. Debe ser mayor a cero.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBoxDebug.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBoxDebug.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcBoxDebug.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.render">
            <summary>
                Renderizar la caja
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.dispose">
            <summary>
                Liberar recursos de la línea
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.updateValues">
            <summary>
                Actualizar parámetros de la caja en base a los valores configurados
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.createLineX(Microsoft.DirectX.Direct3D.CustomVertex.PositionColored[],System.Int32,System.Int32,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crear linea en X
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.createLineY(Microsoft.DirectX.Direct3D.CustomVertex.PositionColored[],System.Int32,System.Int32,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crear linea en Y
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.createLineZ(Microsoft.DirectX.Direct3D.CustomVertex.PositionColored[],System.Int32,System.Int32,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crear linea en Z
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.createLineVertices(Microsoft.DirectX.Direct3D.CustomVertex.PositionColored[],System.Int32,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Int32)">
            <summary>
                Crear los vértices de la línea con valores extremos especificados
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.setPositionSize(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Configurar valores de posicion y tamaño en forma conjunta
            </summary>
            <param name="position">Centro de la caja</param>
            <param name="size">Tamaño de la caja</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.fromSize(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una caja con el centro y tamaño especificado
            </summary>
            <param name="center">Centro de la caja</param>
            <param name="size">Tamaño de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.fromSize(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Drawing.Color)">
            <summary>
                Crea una caja con el centro y tamaño especificado, con color especificado
            </summary>
            <param name="center">Centro de la caja</param>
            <param name="size">Tamaño de la caja</param>
            <param name="color">Color de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.fromSize(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Drawing.Color,System.Single)">
            <summary>
                Crea una caja con el centro y tamaño especificado, con el grosor y color especificado
            </summary>
            <param name="center">Centro de la caja</param>
            <param name="size">Tamaño de la caja</param>
            <param name="color">Color de la caja</param>
            <param name="thickness">Grosor de las aristas de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.fromExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una caja en base al punto minimo y maximo
            </summary>
            <param name="pMin">Punto mínimo</param>
            <param name="pMax">Punto máximo</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.fromExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Drawing.Color)">
            <summary>
                Crea una caja en base al punto minimo y maximo, con el color especificado
            </summary>
            <param name="pMin">Punto mínimo</param>
            <param name="pMax">Punto máximo</param>
            <param name="color">Color de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcBoxDebug.fromExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Drawing.Color,System.Single)">
            <summary>
                Crea una caja en base al punto minimo y maximo, con el grosor y color especificado
            </summary>
            <param name="pMin">Punto mínimo</param>
            <param name="pMax">Punto máximo</param>
            <param name="color">Color de la caja</param>
            <param name="thickness">Grosor de las aristas de la caja</param>
            <returns>Caja creada</returns>
        </member>
        <member name="T:TGC.Core.Geometry.TgcLine">
            <summary>
                Herramienta para crear una línea 3D y renderizarla con color.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcLine.PStart">
            <summary>
                Punto de inicio de la linea
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcLine.PEnd">
            <summary>
                Punto final de la linea
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcLine.Color">
            <summary>
                Color de la linea
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcLine.Enabled">
            <summary>
                Indica si la linea esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcLine.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcLine.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcLine.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcLine.render">
            <summary>
                Renderizar la línea
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcLine.dispose">
            <summary>
                Liberar recursos de la línea
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcLine.updateValues">
            <summary>
                Actualizar parámetros de la línea en base a los valores configurados
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcLine.fromExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una línea en base a sus puntos extremos
            </summary>
            <param name="start">Punto de inicio</param>
            <param name="end">Punto de fin</param>
            <returns>Línea creada</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcLine.fromExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Drawing.Color)">
            <summary>
                Crea una línea en base a sus puntos extremos, con el color especificado
            </summary>
            <param name="start">Punto de inicio</param>
            <param name="end">Punto de fin</param>
            <param name="color">Color de la línea</param>
            <returns>Línea creada</returns>
        </member>
        <member name="T:TGC.Core.Geometry.TgcPickingRay">
            <summary>
                Utilidad para crear
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPickingRay.Ray">
            <summary>
                Ray que representa la accion de Picking
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPickingRay.updateRay">
            <summary>
                Actualiza el Ray de colision en base a la posicion del mouse en la pantalla
            </summary>
        </member>
        <member name="T:TGC.Core.Geometry.TgcPlane">
            <summary>
                Pared 3D plana que solo crece en dos dimensiones.
            </summary>
        </member>
        <member name="T:TGC.Core.Geometry.TgcPlane.Orientations">
            <summary>
                Orientaciones posibles de la pared
            </summary>
        </member>
        <member name="F:TGC.Core.Geometry.TgcPlane.Orientations.XYplane">
            <summary>
                Pared vertical a lo largo de X
            </summary>
        </member>
        <member name="F:TGC.Core.Geometry.TgcPlane.Orientations.XZplane">
            <summary>
                Pared horizontal
            </summary>
        </member>
        <member name="F:TGC.Core.Geometry.TgcPlane.Orientations.YZplane">
            <summary>
                Pared vertical a lo largo de Z
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.#ctor">
            <summary>
                Crea una pared vacia.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.#ctor(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,TGC.Core.Geometry.TgcPlane.Orientations,TGC.Core.Textures.TgcTexture,System.Single,System.Single)">
            <summary>
                Crea una pared con un punto de origen, el tamaño de la pared y la orientación de la misma, especificando
                el tiling de la textura
            </summary>
            <param name="origin">Punto de origen de la pared</param>
            <param name="size">Dimensiones de la pared. Uno de los valores será ignorado, según la orientación elegida</param>
            <param name="orientation">Orientacion de la pared</param>
            <param name="texture">Textura de la pared</param>
            <param name="uTile">Cantidad de tile de la textura en coordenada U</param>
            <param name="vTile">Cantidad de tile de la textura en coordenada V</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.#ctor(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,TGC.Core.Geometry.TgcPlane.Orientations,TGC.Core.Textures.TgcTexture)">
            <summary>
                Crea una pared con un punto de origen, el tamaño de la pared y la orientación de la misma, con ajuste automatico
                de coordenadas de textura
            </summary>
            <param name="origin">Punto de origen de la pared</param>
            <param name="size">Dimensiones de la pared. Uno de los valores será ignorado, según la orientación elegida</param>
            <param name="orientation">Orientacion de la pared</param>
            <param name="texture">Textura de la pared</param>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.Origin">
            <summary>
                Origen de coordenadas de la pared.
                Llamar a updateValues() para aplicar cambios.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.Size">
            <summary>
                Dimensiones de la pared.
                Llamar a updateValues() para aplicar cambios.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.Orientation">
            <summary>
                Orientación de la pared.
                Llamar a updateValues() para aplicar cambios.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.Texture">
            <summary>
                Textura de la pared
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.UTile">
            <summary>
                Cantidad de tile de la textura en coordenada U.
                Llamar a updateValues() para aplicar cambios.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.VTile">
            <summary>
                Cantidad de tile de la textura en coordenada V.
                Llamar a updateValues() para aplicar cambios.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.AutoAdjustUv">
            <summary>
                Auto ajustar coordenadas UV en base a la relación de tamaño de la pared y la textura
                Llamar a updateValues() para aplicar cambios.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.UVOffset">
            <summary>
                Offset UV de textura
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.Enabled">
            <summary>
                Indica si la pared esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.BoundingBox">
            <summary>
                BoundingBox de la pared
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcPlane.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.render">
            <summary>
                Renderizar la pared
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.dispose">
            <summary>
                Liberar recursos de la pared
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.setExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Configurar punto minimo y maximo de la pared.
                Se ignora un valor de cada punto según la orientación elegida.
                Llamar a updateValues() para aplicar cambios.
            </summary>
            <param name="min">Min</param>
            <param name="max">Max</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.updateValues">
            <summary>
                Actualizar parámetros de la pared en base a los valores configurados
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.setTexture(TGC.Core.Textures.TgcTexture)">
            <summary>
                Configurar textura de la pared
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.activateAlphaBlend">
            <summary>
                Activar AlphaBlending, si corresponde
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.resetAlphaBlend">
            <summary>
                Desactivar AlphaBlending
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.toMesh(System.String)">
            <summary>
                Convierte la pared en un TgcMesh
            </summary>
            <param name="meshName">Nombre de la malla que se va a crear</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcPlane.clone">
            <summary>
                Crear un nuevo Plane igual a este
            </summary>
            <returns>Plane clonado</returns>
        </member>
        <member name="T:TGC.Core.Geometry.TgcQuad">
            <summary>
                Herramienta para crear un Quad 3D, o un plano con ancho y largo acotado,
                en base al centro y una normal.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcQuad.Center">
            <summary>
                Centro del plano
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcQuad.Normal">
            <summary>
                Normal del plano
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcQuad.Size">
            <summary>
                Tamaño del plano, en ancho y longitud
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcQuad.Color">
            <summary>
                Color del plano
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcQuad.Enabled">
            <summary>
                Indica si el plano habilitado para ser renderizado
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcQuad.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcQuad.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcQuad.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcQuad.render">
            <summary>
                Renderizar el Quad
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcQuad.dispose">
            <summary>
                Liberar recursos de la flecha
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcQuad.updateValues">
            <summary>
                Actualizar parámetros del plano en base a los valores configurados
            </summary>
        </member>
        <member name="T:TGC.Core.Geometry.TgcRay">
            <summary>
                Representa un Ray 3D con un origen y una direccion, de la forma: r = p + td
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcRay.#ctor(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Se normaliza la direccion
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcRay.Origin">
            <summary>
                Punto de origen del Ray
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcRay.Direction">
            <summary>
                Direccion del Ray
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcRay.toStruct">
            <summary>
                Convertir a Struct
            </summary>
        </member>
        <member name="T:TGC.Core.Geometry.TgcRay.RayStruct">
            <summary>
                Ray en un struct liviano
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcRay.RayStruct.toClass">
            <summary>
                Convertir a clase
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.clone">
            <summary>
                Crear un nuevo TgcSphere igual a este
            </summary>
            <returns>Sphere clonado</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.toMesh(System.String)">
            <summary>
                Convierte el TgcSphere en un TgcMesh
            </summary>
            <param name="meshName">Nombre de la malla que se va a crear</param>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.RenderEdges">
            <summary>
                Cuando esta en true se renderiza tambien el wireframe.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.ForceUpdate">
            <summary>
                Obliga a la esfera a recalcular sus vertices.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.VertexCount">
            <summary>
                Cantidad de vertices
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.TriangleCount">
            <summary>
                Cantidad de triangulos
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Radius">
            <summary>
                Radio de la esfera
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.LevelOfDetail">
            <summary>
                Nivel de detalle de la esfera. La cantidad de veces que se subdividen los triangulos de la superficie.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Scale">
            <summary>
                Escala de la esfera. Siempre es (1,1,1)
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Color">
            <summary>
                Color de los vértices de la esfera
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Texture">
            <summary>
                Textura de la esfera
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Transform">
            <summary>
                Matriz final que se utiliza para aplicar transformaciones a la malla.
                Si la propiedad AutoTransformEnable esta en True, la matriz se reconstruye en cada cuadro
                en base a los valores de: Position, Rotation, Scale.
                Si AutoTransformEnable está en False, se respeta el valor que el usuario haya cargado en la matriz.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.AutoTransformEnable">
            <summary>
                En True hace que la matriz de transformacion (Transform) de la malla se actualiza en
                cada cuadro en forma automática, según los valores de: Position, Rotation, Scale.
                En False se respeta lo que el usuario haya cargado a mano en la matriz.
                Por default está en False.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Position">
            <summary>
                Posicion absoluta del centro de la esfera
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Rotation">
            <summary>
                Rotación absoluta de la esfera
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Enabled">
            <summary>
                Indica si la esfera esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.BoundingSphere">
            <summary>
                BoundingSphere de la esfera
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.UVOffset">
            <summary>
                Offset UV de textura
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.UVTiling">
            <summary>
                Tiling UV de textura
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.BasePoly">
            <summary>
                Poliedro que se utiliza como base para la creacion de la esfera.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcSphere.Inflate">
            <summary>
                Cuando esta en false se puede ver el poliedro original con sus subdivisiones.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.setColor(System.Drawing.Color)">
            <summary>
                Configurar color de la esfera y setea la technique POSITION_COLORED. Unsetea la textura.
            </summary>
            <param name="color"></param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.setTexture(TGC.Core.Textures.TgcTexture)">
            <summary>
                Configurar textura de la esfera y setea la technique POSITION_TEXTURED.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.setPositionRadius(Microsoft.DirectX.Vector3,System.Single)">
            <summary>
                Configurar valores de posicion y radio en forma conjunta
            </summary>
            <param name="position">Centro de la esfera</param>
            <param name="size">Radio de la esfera</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.#ctor">
            <summary>
                Crea una esfera vacia
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.#ctor(System.Single,System.Drawing.Color,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una esfera con el radio, color y posicion del centro.
            </summary>
            <param name="radius"></param>
            <param name="color"></param>
            <param name="center"></param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.#ctor(System.Single,TGC.Core.Textures.TgcTexture,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una esfera con radio, textura y posicion del centro.
            </summary>
            <param name="radius"></param>
            <param name="texture"></param>
            <param name="center"></param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.updateValues">
            <summary>
                Vuelve a crear la esfera si hubo cambio en el nivel de detalle, color o coordenadas de textura o si ForceUpdate
                esta en true.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.createSphereSubdividingAPolyhedron(System.Collections.Generic.List{Microsoft.DirectX.Vector3}@,System.Collections.Generic.List{System.Int32}@)">
            <summary>
                Subdivide el poliedro base y normaliza los vertices para que formen una esfera de radio 1.
            </summary>
            <param name="vertices"></param>
            <param name="indices"></param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.fixTexcoords(System.Collections.Generic.List{TGC.Core.Geometry.Vertex.PositionColoredTexturedNormal},System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},System.Int32[])">
            <summary>
                Duplica los vertices que deben tener coordenadas de textura diferentes para diferentes triangulos
            </summary>
            <param name="vertices"></param>
            <param name="indices"></param>
            <param name="iverticesU1"></param>
            <param name="polos"></param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.dupWithU(System.Collections.Generic.List{TGC.Core.Geometry.Vertex.PositionColoredTexturedNormal},System.Collections.Generic.List{System.Int32},System.Collections.Generic.Dictionary{System.Int32,System.Int32},System.Int32,System.Single)">
            <summary>
                Busca el duplicado del vertice con texcoord u, si no existe lo crea y retorna el indice.
            </summary>
            <param name="vertices"></param>
            <param name="indices"></param>
            <param name="dDup"></param>
            <param name="idx"></param>
            <param name="u"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.render">
            <summary>
                Renderizar la esfera
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.activateAlphaBlend">
            <summary>
                Activar AlphaBlending, si corresponde
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.resetAlphaBlend">
            <summary>
                Desactivar AlphaBlending
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.dispose">
            <summary>
                Liberar los recursos de la esfera
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.move(Microsoft.DirectX.Vector3)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.move(System.Single,System.Single,System.Single)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.moveOrientedY(System.Single)">
            <summary>
                Mueve la malla en base a la orientacion actual de rotacion.
                Es necesario rotar la malla primero
            </summary>
            <param name="movement">Desplazamiento. Puede ser positivo (hacia adelante) o negativo (hacia atras)</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.getPosition(Microsoft.DirectX.Vector3)">
            <summary>
                Obtiene la posicion absoluta de la malla, recibiendo un vector ya creado para
                almacenar el resultado
            </summary>
            <param name="pos">Vector ya creado en el que se carga el resultado</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.rotateX(System.Single)">
            <summary>
                Rota la malla respecto del eje X
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.rotateY(System.Single)">
            <summary>
                Rota la malla respecto del eje Y
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.rotateZ(System.Single)">
            <summary>
                Rota la malla respecto del eje Z
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.Geometry.TgcSphere.updateBoundingVolume">
            <summary>
                Actualiza el BoundingSphere de la esfera
            </summary>
        </member>
        <member name="T:TGC.Core.Geometry.GeometryProvider">
            <remarks> http://gamedev.stackexchange.com/questions/31308/algorithm-for-creating-spheres David Lively</remarks>
        </member>
        <member name="M:TGC.Core.Geometry.GeometryProvider.Subdivide(System.Collections.Generic.List{Microsoft.DirectX.Vector3},System.Collections.Generic.List{System.Int32})">
            <summary> Divide cada triangulo en cuatro.</summary>
            <remarks>
                i0
                /  \
                m02-m01
                /  \ /  \
                i2---m12---i1
            </remarks>
            <param name="vectors"></param>
            <param name="indices"></param>
        </member>
        <member name="M:TGC.Core.Geometry.GeometryProvider.GetMidpointIndex(System.Collections.Generic.Dictionary{System.String,System.Int32},System.Collections.Generic.List{Microsoft.DirectX.Vector3},System.Int32,System.Int32)">
            <summary>
                Busca el indice del vertice que se encuentra entre los vertices i0 e i1, de no existir crea el vertice.
            </summary>
            <param name="midpointIndices"></param>
            <param name="vertices"></param>
            <param name="i0"></param>
            <param name="i1"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Geometry.GeometryProvider.Cube(System.Collections.Generic.List{Microsoft.DirectX.Vector3},System.Collections.Generic.List{System.Int32})">
            <summary>
                Retorna la posicion de los vertices y los indices de un cubo.
            </summary>
            <param name="vertices"></param>
            <param name="indices"></param>
        </member>
        <member name="M:TGC.Core.Geometry.GeometryProvider.Icosahedron(System.Collections.Generic.List{Microsoft.DirectX.Vector3},System.Collections.Generic.List{System.Int32})">
            <summary>
                Retorna la posicion de los vertices y los indices de un icosaedro regular (Un d20)
            </summary>
            <param name="vertices"></param>
            <param name="indices"></param>
        </member>
        <member name="T:TGC.Core.Geometry.TgcTriangle">
            <summary>
                Herramienta para crear un Triangulo 3D.
                No está pensado para rasterizar gran cantidad de triangulos, sino mas
                para una herramienta de debug.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcTriangle.A">
            <summary>
                Primer vértice del triángulo
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcTriangle.B">
            <summary>
                Segundo vértice del triángulo
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcTriangle.C">
            <summary>
                Tercer vértice del triángulo
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcTriangle.Color">
            <summary>
                Color del plano
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcTriangle.Enabled">
            <summary>
                Indica si el plano habilitado para ser renderizado
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcTriangle.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcTriangle.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcTriangle.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcTriangle.render">
            <summary>
                Renderizar el Triángulo
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcTriangle.dispose">
            <summary>
                Liberar recursos de la flecha
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcTriangle.updateValues">
            <summary>
                Actualizar parámetros del triángulo en base a los valores configurados
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcTriangle.computeNormal">
            <summary>
                Calcular normal del Triángulo
            </summary>
            <returns>Normal (esta normalizada)</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcTriangle.computeCenter">
            <summary>
                Calcular centro del Triángulo
            </summary>
            <returns>Centro</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcTriangle.createNormalArrow">
            <summary>
                Crea una flecha a modo debug para mostrar la normal de la cara del triangulo
            </summary>
            <returns>TgcArrow que representa la face-normal</returns>
        </member>
        <member name="M:TGC.Core.Geometry.TgcTriangle.toMesh(System.String)">
            <summary>
                Convierte el Triángulo en un TgcMesh
            </summary>
            <param name="meshName">Nombre de la malla que se va a crear</param>
        </member>
        <member name="T:TGC.Core.Geometry.TgcTriangleArray">
            <summary>
                Herramienta para dibujar una lista de triangulos.
                No está pensado para rasterizar en forma performante, sino mas
                para una herramienta de debug.
            </summary>
        </member>
        <member name="P:TGC.Core.Geometry.TgcTriangleArray.Triangles">
            <summary>
                Triangulos
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcTriangleArray.fromMesh(TGC.Core.SceneLoader.TgcMesh,TGC.Core.Input.TgcD3dInput)">
            <summary>
                Crear a partir de un mesh
            </summary>
        </member>
        <member name="M:TGC.Core.Geometry.TgcTriangleArray.pickTriangle(TGC.Core.Geometry.TgcTriangle@,System.Int32@)">
            <summary>
                Picking sobre un triangulo
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox">
            <summary>
                Representa un Axis Aliang Bounding Box
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.#ctor">
            <summary>
                Construir AABB vacio
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.#ctor(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Construir AABB
            </summary>
            <param name="pMin">Punto mínimo</param>
            <param name="pMax">Punto máximo</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.#ctor(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Construye un AABB a partir de un pMin y pMax que ya tienen aplicada una escala y una traslacion.
            </summary>
            <param name="pMin">Punto minimo escalado y/o trasladado</param>
            <param name="pMax">Punto maximo escalado y/o trasladado</param>
            <param name="position">Traslacion</param>
            <param name="scale">Escala</param>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.PMin">
            <summary>
                Punto mínimo del BoundingBox
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.PMax">
            <summary>
                Punto máximo del BoundinBox
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.RenderColor">
            <summary>
                Color de renderizado del BoundingBox.
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.render">
            <summary>
                Renderizar BoundingBox
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.dispose">
            <summary>
                Libera los recursos del objeto
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.setExtremes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Configurar los valores extremos del BoundingBox
            </summary>
            <param name="pMin">Punto mínimo</param>
            <param name="pMax">Punto máximo</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.setRenderColor(System.Drawing.Color)">
            <summary>
                Configurar el color de renderizado del BoundingBox
                Ejemplo: Color.Yellow.ToArgb();
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.calculateBoxRadiusSquare">
            <summary>
                Radio al cuadrado del BoundingBox
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.calculateBoxRadius">
            <summary>
                Radio del BoundingBox
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.calculateBoxCenter">
            <summary>
                Centro del Bounding Box
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.calculateSize">
            <summary>
                Tamaño de cada dimensión del BoundingBox
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.calculateAxisRadius">
            <summary>
                Devuelve el radio de cada eje (o Extents)
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.scaleTranslate(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
            Traslada y escala el BoundingBox.
            Si el BoundingBox tenia alguna rotación, se pierde.
            </summary>
            <param name="position">Nueva posición absoluta de referencia</param>
            <param name="scale">Nueva escala absoluta de referencia</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.move(Microsoft.DirectX.Vector3)">
            <summary>
                Mueve el BoundingBox
            </summary>
            <param name="movement">Movimiento relativo que se quiere aplicar</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.transform(Microsoft.DirectX.Matrix)">
            <summary>
                Transforma el BondingBox en base a una matriz de transformación.
                Esto implica escalar, rotar y trasladar.
                El procedimiento es mas costoso que solo hacer scaleTranslate().
                Se construye un nuevo BoundingBox en base a los puntos extremos del original
                más la transformación pedida.
                Si el BoundingBox se transformó y luego se llama a scaleTranslate(), se respeta
                la traslación y la escala, pero la rotación se va a perder.
            </summary>
            <param name="transform"></param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.updateValues">
            <summary>
                Actualizar los valores de los vertices a renderizar
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.computeCorners(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea un array con los 8 vertices del BoundingBox, en base a los extremos especificados
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.computeCorners">
            <summary>
                Crea un array con los 8 vertices del BoundingBox
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.computeFaces">
            <summary>
                Calcula los polígonos que conforman las 6 caras del BoundingBox
            </summary>
            <returns>Array con las 6 caras del polígono en el siguiente orden: Up, Down, Front, Back, Right, Left</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.clone">
            <summary>
                Crear un BoundingBox igual a este
            </summary>
            <returns>BoundingBox clonado</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.projectToScreen">
            <summary>
                Proyecta el BoundingBox a un rectangulo 2D de screen space
            </summary>
            <returns>Rectangulo 2D con proyeccion en screen space</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.toStruct">
            <summary>
                Convertir a struct
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.Face">
            <summary>
                Cara de un BoundingBox representada por un polígono rectangular de 4 vértices.
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.Face.Extremes">
            <summary>
                Los 4 vértices extremos de la cara
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.Face.Plane">
            <summary>
                Ecuación del plano que engloba la cara, con su normal apuntado hacia afuera normalizada.
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.AABBStruct">
            <summary>
                BoundingBox en un struct liviano
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.AABBStruct.toClass">
            <summary>
                Convertir a clase
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.computeFromBoundingBoxes(System.Collections.Generic.List{TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox})">
            <summary>
                Crea un BoundingBox que contenga a todos los BoundingBoxes especificados
            </summary>
            <param name="boundingBoxes">Lista BoundingBoxes a contener</param>
            <returns>BoundingBox creado</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.computeFromPoints(Microsoft.DirectX.Vector3[])">
            <summary>
                Crea un BoundingBox a partir de un conjunto de puntos.
            </summary>
            <param name="points">Puntos a conentener</param>
            <returns>BoundingBox creado</returns>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingCylinder">
            <summary>
                Cilindro Bounding con posibilidad de orietar y rotar, este puede ser utilizado por ejemplo para personajes.
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinder.HalfHeight">
            <summary>
                Devuelve el vector HalfHeight (va del centro a la tapa superior del cilindro)
                Se utiliza para testeo de colisiones
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinder.Direction">
            <summary>
                Devuelve el vector Direccion (apunta desde el centro hacia la tapa superior)
                Esta normalizado
                Se utiliza para testeo de colisiones
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinder.HalfLength">
            <summary>
                Media altura del cilindro
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinder.Length">
            <summary>
                Altura del cilindro
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinder.Radius">
            <summary>
                Radio del cilindro
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinder.Center">
            <summary>
                Centro del cilindro
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingCylinder.updateValues">
            <summary>
                Actualiza la matriz de transformacion
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingCylinder.calculateSphereRadius">
            <summary>
                Calcula el radio de la esfera que contiene al cilindro
                Se la puede utilizar para acelerar el testeo de colisiones
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingCylinder.updateDraw">
            <summary>
                Actualiza la posicion de los vertices que componen las tapas y los vertices de las lineas laterales.
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinder.AntiRotationMatrix">
            <summary>
                Matriz que lleva cualquier punto al espacio UVW del cilindro
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinder.AntiTransformationMatrix">
            <summary>
                Matriz que lleva el radio del cilindro a 1, la altura a 2, y el centro al origen de coordenadas
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingSphere">
            <summary>
                Representa un volumen de esfera con un centro y un radio
            </summary>
        </member>
        <member name="F:TGC.Core.BoundingVolumes.TgcBoundingSphere.SPHERE_MESH_RESOLUTION">
            <summary>
                Cantidad de tramos que tendrá el mesh del BoundingSphere a dibujar
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.#ctor">
            <summary>
                Crear BoundingSphere vacia
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.#ctor(Microsoft.DirectX.Vector3,System.Single)">
            <summary>
                Crear BoundingSphere con centro y radio
            </summary>
            <param name="center">Centro</param>
            <param name="radius">Radio</param>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingSphere.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingSphere.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingSphere.Center">
            <summary>
                Centro de la esfera
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingSphere.Radius">
            <summary>
                Radio de la esfera
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingSphere.RenderColor">
            <summary>
                Color de renderizado del BoundingBox.
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingSphere.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.render">
            <summary>
                Renderizar el BoundingSphere
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.dispose">
            <summary>
                Libera los recursos del objeto
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.setValues(Microsoft.DirectX.Vector3,System.Single)">
            <summary>
                Configurar valores del BoundingSphere
            </summary>
            <param name="center">Centro</param>
            <param name="radius">Radio</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.setCenter(Microsoft.DirectX.Vector3)">
            <summary>
                Configurar un nuevo centro del BoundingSphere
            </summary>
            <param name="center">Nuevo centro</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.moveCenter(Microsoft.DirectX.Vector3)">
            <summary>
                Desplazar el centro respecto de su posición actual
            </summary>
            <param name="movement">Movimiento relativo a realizar</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.setRenderColor(System.Drawing.Color)">
            <summary>
                Configurar el color de renderizado del BoundingBox
                Ejemplo: Color.Yellow.ToArgb();
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.updateValues">
            <summary>
                Construye el mesh del BoundingSphere
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.toStruct">
            <summary>
                Convertir a struct
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingSphere.SphereStruct">
            <summary>
                BoundingSphere en un struct liviano
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.SphereStruct.toClass">
            <summary>
                Convertir a clase
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.computeFromMesh(TGC.Core.SceneLoader.TgcMesh)">
            <summary>
                Crea un BoundingSphere a partir de los vertices de un Mesh, utilizando el algoritmo de Ritter
            </summary>
            <param name="mesh">Mesh a partir del cual crear el BoundingSphere</param>
            <returns>BoundingSphere creado</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.computeFromPoints(Microsoft.DirectX.Vector3[])">
            <summary>
                Crear un BoundingSphere a partir de un conjunto de puntos, utilizando el algoritmo de Ritter:
                [Ritter, Jack. "An Efficient Bounding Sphere," in Andrew Glassner (ed.), Graphics Gems, Academic Press, pp.
                301–303, 1990.]
            </summary>
            <param name="pt">Puntos a partir del cual calcular el BoundingSphere</param>
            <returns>BoundingSphere calculado</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.sphereOfSphereAndPt(TGC.Core.BoundingVolumes.TgcBoundingSphere.SphereStruct@,Microsoft.DirectX.Vector3)">
            <summary>
                Given Sphere s and Point p, update s (if needed) to just encompass p
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.sphereFromDistantPoints(Microsoft.DirectX.Vector3[])">
            <summary>
                Crear esfera a partir de los puntos mas distintas
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingSphere.mostSeparatedPointsOnAABB(Microsoft.DirectX.Vector3[],System.Int32@,System.Int32@)">
            <summary>
                Compute indices to the two most separated points of the (up to) six points
                defining the AABB encompassing the point set. Return these as min and max.
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingElipsoid">
            <summary>
                Representa un volumen de Elipsoide con un centro y un radio distinto para cada uno de los tres ejes
            </summary>
        </member>
        <member name="F:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.ELIPSOID_MESH_RESOLUTION">
            <summary>
                Cantidad de tramos que tendrá el mesh del Elipsoid a dibujar
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.#ctor">
            <summary>
                Crear Elipsoid vacia
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.#ctor(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crear Elipsoid con centro y radio
            </summary>
            <param name="center">Centro</param>
            <param name="radius">Radios para los 3 ejes</param>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.Center">
            <summary>
                Centro del Elipsoid
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.Radius">
            <summary>
                Radios del Elipsoid para cada uno de los 3 ejes
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.RenderColor">
            <summary>
                Color de renderizado del Elipsoid.
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.render">
            <summary>
                Renderizar el Elipsoid
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.dispose">
            <summary>
                Libera los recursos del objeto
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.setValues(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Configurar valores del Elipsoid
            </summary>
            <param name="center">Centro</param>
            <param name="radius">Radios para los 3 ejes</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.setCenter(Microsoft.DirectX.Vector3)">
            <summary>
                Configurar un nuevo centro del Elipsoid
            </summary>
            <param name="center">Nuevo centro</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.moveCenter(Microsoft.DirectX.Vector3)">
            <summary>
                Desplazar el centro respecto de su posición actual
            </summary>
            <param name="movement">Movimiento relativo a realizar</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.setRenderColor(System.Drawing.Color)">
            <summary>
                Configurar el color de renderizado del Elipsoid
                Ejemplo: Color.Yellow.ToArgb();
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.updateValues">
            <summary>
                Construye el mesh del Elipsoid
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.getMaxRadius">
            <summary>
                Devuelve el radio mas grande del Elipsoid
            </summary>
            <returns>Mayor radio</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.toStruct">
            <summary>
                Convertir a struct
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.ElipsoidStruct">
            <summary>
                Elipsoid en un struct liviano
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingElipsoid.ElipsoidStruct.toClass">
            <summary>
                Convertir a clase
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY">
            <summary>
                Cilindro Bounding alineado a al eje Y, este puede ser utilizado por ejemplo para personajes.
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY.HalfHeight">
            <summary>
                Devuelve el vector HalfHeight (va del centro a la tapa superior del cilindro)
                Se utiliza para testeo de colisiones
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY.AntiTransformationMatrix">
            <summary>
                Matriz que lleva el radio del cilindro a 1, la altura a 2, y el centro al origen de coordenadas
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY.Center">
            <summary>
                Centro del cilindro
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY.Radius">
            <summary>
                Radio del cilindro
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY.HalfLength">
            <summary>
                Media altura del cilindro
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY.Length">
            <summary>
                Altura del cilindro
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY.updateValues">
            <summary>
                Actualiza la matriz de transformacion
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY.updateDraw">
            <summary>
                Actualiza la posicion de los vertices que componen las tapas
                y los vertices de las lineas laterales. FIXME este update puede ser una transformacion solamente.
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcFrustum">
            <summary>
                Clase que representa el volumen del Frustum (vision actual).
                Las normales de los planos del Frustum apuntan hacia adentro.
                Tambien permite dibujar una malla debug del frustum
                Solo puede ser invocado cuando se esta ejecutando un bloque de Render() de un TgcExample
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcFrustum.PlaneTypes">
            <summary>
                Tipos de planos del Frustum
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.VertexBuffer">
            <summary>
                VertexBuffer para mesh debug de Frustum
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.FrustumPlanes">
            <summary>
                Los 6 planos que componen el Frustum.
                Estan en el siguiente orden:
                Left, Right, Top, Bottom, Near, Far
                Estan normalizados.
                Sus normales hacia adentro.
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.LeftPlane">
            <summary>
                Left plane
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.RightPlane">
            <summary>
                Right plane
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.TopPlane">
            <summary>
                Top plane
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.BottomPlane">
            <summary>
                Bottom plane
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.NearPlane">
            <summary>
                Near plane
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.FarPlane">
            <summary>
                Far plane
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.AlphaBlendingValue">
            <summary>
                Transparencia (0, 1)
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcFrustum.Color">
            <summary>
                Color del mesh debug
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcFrustum.updateVolume(Microsoft.DirectX.Matrix,Microsoft.DirectX.Matrix)">
            <summary>
                Actualiza los planos que conforman el volumen del Frustum.
                Los planos se calculan con las normales apuntando hacia adentro
            </summary>
            <param name="viewMatrix">View matrix</param>
            <param name="projectionMatrix">Projection matrix</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcFrustum.computeFrustumCorners(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Calcular los 8 vertices del Frustum
                Basado en: http://www.lighthouse3d.com/tutorials/view-frustum-culling/geometric-approach-implementation/
            </summary>
            <param name="position"></param>
            <param name="lookAt"></param>
            <param name="aspectRatio"></param>
            <param name="nearDistance"></param>
            <param name="farDistance"></param>
            <param name="fieldOfViewY"></param>
            <returns>Los 8 vertices del Frustum</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcFrustum.updateMesh(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Actualizar el mesh para debug del Frustum
            </summary>
            <param name="position"></param>
            <param name="lookAt"></param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcFrustum.updateMesh(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Single,System.Single,System.Single,System.Single)">
            <summary>
                Actualizar el mesh para debug del Frustum
                Basado en: http://zach.in.tu-clausthal.de/teaching/cg_literatur/lighthouse3d_view_frustum_culling/index.html
            </summary>
            <param name="position"></param>
            <param name="lookAt"></param>
            <param name="aspectRatio"></param>
            <param name="nearDistance"></param>
            <param name="farDistance"></param>
            <param name="fieldOfViewY"></param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcFrustum.render">
            <summary>
                Dibujar mesh debug del Frustum.
                Antes se debe llamar a updateMesh()
                Setear el effect para el shader antes
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcFrustum.dispose">
            <summary>
                Liberar recursos
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox">
            <summary>
                Representa un Orientend-BoundingBox (OBB)
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.#ctor">
            <summary>
                Construir OBB vacio
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.Center">
            <summary>
                Centro
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.Orientation">
            <summary>
                Orientacion del OBB, expresada en local axes
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.Extents">
            <summary>
                Radios
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.RenderColor">
            <summary>
                Color de renderizado del BoundingBox.
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.render">
            <summary>
                Renderizar
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.dispose">
            <summary>
                Libera los recursos del objeto
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.setRenderColor(System.Drawing.Color)">
            <summary>
                Configurar el color de renderizado del OBB
                Ejemplo: Color.Yellow.ToArgb();
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.updateValues">
            <summary>
                Actualizar los valores de los vertices a renderizar
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.computeCorners">
            <summary>
                Crea un array con los 8 vertices del OBB
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.move(Microsoft.DirectX.Vector3)">
            <summary>
                Mueve el centro del OBB
            </summary>
            <param name="movement">Movimiento relativo que se quiere aplicar</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.rotate(Microsoft.DirectX.Vector3)">
            <summary>
                Rotar OBB en los 3 ejes.
                Es una rotacion relativa, sumando a lo que ya tenia antes de rotacion.
            </summary>
            <param name="movement">Ángulo de rotación de cada eje en radianes</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.setRotation(Microsoft.DirectX.Vector3)">
            <summary>
                Cargar la rotacion absoluta del OBB.
                Pierda la rotacion anterior.
            </summary>
            <param name="rotation">Ángulo de rotación de cada eje en radianes</param>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.computeRotationMatrix">
            <summary>
                Calcula la matriz de rotacion 4x4 del Obb en base a su orientacion
            </summary>
            <returns>Matriz de rotacion de 4x4</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.computeFromPoints(Microsoft.DirectX.Vector3[])">
            <summary>
                Calcular OBB a partir de un conjunto de puntos.
                Busca por fuerza bruta el mejor OBB en la mejor orientación que se ajusta a esos puntos.
                Es un calculo costoso.
            </summary>
            <param name="points">puntos</param>
            <returns>OBB calculado</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.computeFromPointsRecursive(Microsoft.DirectX.Vector3[],Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Single)">
            <summary>
                Calcular OBB a partir de un conjunto de puntos.
                Prueba todas las orientaciones entre initValues y endValues, saltando de angulo en cada intervalo segun step
                Continua recursivamente hasta llegar a un step menor a 0.01f
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.computeFromAABB(TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Generar OBB a partir de AABB
            </summary>
            <param name="aabb">BoundingBox</param>
            <returns>OBB generado</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.computeFromAABB(TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.AABBStruct)">
            <summary>
                Generar OBB a partir de AABB
            </summary>
            <param name="aabb">BoundingBox</param>
            <returns>OBB generado</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.toObbSpace(Microsoft.DirectX.Vector3)">
            <summary>
                Convertir un punto de World-Space espacio de coordenadas del OBB (OBB-Space)
            </summary>
            <param name="p">Punto en World-space</param>
            <returns>Punto convertido a OBB-space</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.toWorldSpace(Microsoft.DirectX.Vector3)">
            <summary>
                Convertir un punto de OBB-space a World-space
            </summary>
            <param name="p">Punto en OBB-space</param>
            <returns>Punto convertido a World-space</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.toStruct">
            <summary>
                Convertir a struct
            </summary>
        </member>
        <member name="T:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.OBBStruct">
            <summary>
                OBB en un struct liviano
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.OBBStruct.toClass">
            <summary>
                Convertir a clase
            </summary>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.OBBStruct.toObbSpace(Microsoft.DirectX.Vector3)">
            <summary>
                Convertir un punto de World-Space espacio de coordenadas del OBB (OBB-Space)
            </summary>
            <param name="p">Punto en World-space</param>
            <returns>Punto convertido a OBB-space</returns>
        </member>
        <member name="M:TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.OBBStruct.toWorldSpace(Microsoft.DirectX.Vector3)">
            <summary>
                Convertir un punto de OBB-space a World-space
            </summary>
            <param name="p">Punto en OBB-space</param>
            <returns>Punto convertido a World-space</returns>
        </member>
        <member name="T:TGC.Core.Collision.TgcCollisionUtils">
            <summary>
                Utilidades para hacer detección de colisiones
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.classifyBoxBox(TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Clasifica un BoundingBox respecto de otro. Las opciones de clasificacion son:
                <para># Adentro: box1 se encuentra completamente dentro de la box2</para>
                <para># Afuera: box2 se encuentra completamente afuera de box1</para>
                <para># Atravesando: box2 posee una parte dentro de box1 y otra parte fuera de la box1</para>
                <para>
                    # Encerrando: box1 esta completamente adentro a la box1, es decir, la box1 se encuentra dentro
                    de la box2. Es un caso especial de que box2 esté afuera de box1
                </para>
            </summary>
        </member>
        <member name="T:TGC.Core.Collision.TgcCollisionUtils.BoxBoxResult">
            <summary>
                Resultado de una clasificación BoundingBox-BoundingBox
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.BoxBoxResult.Adentro">
            <summary>
                El BoundingBox 1 se encuentra completamente adentro del BoundingBox 2
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.BoxBoxResult.Afuera">
            <summary>
                El BoundingBox 1 se encuentra completamente afuera del BoundingBox 2
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.BoxBoxResult.Atravesando">
            <summary>
                El BoundingBox 1 posee parte adentro y parte afuera del BoundingBox 2
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.BoxBoxResult.Encerrando">
            <summary>
                El BoundingBox 1 contiene completamente adentro al BoundingBox 2.
                Caso particular de Afuera.
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testAABBAABB(TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Indica si un BoundingBox colisiona con otro.
                Solo indica si hay colisión o no. No va mas en detalle.
            </summary>
            <param name="a">BoundingBox 1</param>
            <param name="b">BoundingBox 2</param>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectRayAABB(TGC.Core.Geometry.TgcRay,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox,Microsoft.DirectX.Vector3@)">
            <summary>
                Indica si un Ray colisiona con un AABB.
                Si hay intersección devuelve True, q contiene
                el punto de intesección.
                Basado en el código de: http://www.codercorner.com/RayAABB.cpp
                La dirección del Ray puede estar sin normalizar.
            </summary>
            <param name="ray">Ray</param>
            <param name="a">AABB</param>
            <param name="q">Punto de intersección</param>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectRayAABB(TGC.Core.Geometry.TgcRay.RayStruct,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.AABBStruct,Microsoft.DirectX.Vector3@)">
            <summary>
                Indica si un Ray colisiona con un AABB.
                Si hay intersección devuelve True, q contiene
                el punto de intesección.
                Basado en el código de: http://www.codercorner.com/RayAABB.cpp
                La dirección del Ray puede estar sin normalizar.
            </summary>
            <param name="ray">Ray</param>
            <param name="a">AABB</param>
            <param name="q">Punto de intersección</param>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectSegmentAABB(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox,Microsoft.DirectX.Vector3@)">
            <summary>
                Indica si el segmento de recta compuesto por p0-p1 colisiona con el BoundingBox.
            </summary>
            <param name="p0">Punto inicial del segmento</param>
            <param name="p1">Punto final del segmento</param>
            <param name="aabb">BoundingBox</param>
            <param name="q">Punto de intersección</param>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.closestPointAABB(Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Dado el punto p, devuelve el punto del contorno del BoundingBox mas próximo a p.
            </summary>
            <param name="p">Punto a testear</param>
            <param name="aabb">BoundingBox a testear</param>
            <returns>Punto mas cercano a p del BoundingBox</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.sqDistPointAABB(Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Calcula la mínima distancia al cuadrado entre el punto p y el BoundingBox.
                Si no se necesita saber el punto exacto de colisión es más ágil que utilizar closestPointAABB().
            </summary>
            <param name="p">Punto a testear</param>
            <param name="aabb">BoundingBox</param>
            <returns>Mínima distacia al cuadrado</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.sqDistPointAABB(Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.AABBStruct)">
            <summary>
                Calcula la mínima distancia al cuadrado entre el punto p y el BoundingBox.
                Si no se necesita saber el punto exacto de colisión es más ágil que utilizar closestPointAABB().
            </summary>
            <param name="p">Punto a testear</param>
            <param name="aabb">BoundingBox</param>
            <returns>Mínima distacia al cuadrado</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testSphereAABB(TGC.Core.BoundingVolumes.TgcBoundingSphere,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Indica si un BoundingSphere colisiona con un BoundingBox.
            </summary>
            <param name="sphere">BoundingSphere</param>
            <param name="aabb">BoundingBox</param>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testSphereAABB(TGC.Core.BoundingVolumes.TgcBoundingSphere.SphereStruct,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.AABBStruct)">
            <summary>
                Indica si un BoundingSphere colisiona con un BoundingBox.
            </summary>
            <param name="sphere">BoundingSphere</param>
            <param name="aabb">BoundingBox</param>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testSphereOBB(TGC.Core.BoundingVolumes.TgcBoundingSphere,TGC.Core.BoundingVolumes.TgcBoundingOrientedBox)">
            <summary>
                Indica si un BoundingSphere colisiona con un BoundingBox.
            </summary>
            <param name="sphere">BoundingSphere</param>
            <param name="aabb">BoundingBox</param>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testSphereOBB(TGC.Core.BoundingVolumes.TgcBoundingSphere.SphereStruct,TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.OBBStruct)">
            <summary>
                Indica si un BoundingSphere colisiona con un BoundingBox.
            </summary>
            <param name="sphere">BoundingSphere</param>
            <param name="aabb">BoundingBox</param>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.classifyPlaneAABB(Microsoft.DirectX.Plane,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Clasifica un BoundingBox respecto de un Plano.
            </summary>
            <param name="plane">Plano</param>
            <param name="aabb">BoundingBox</param>
            <returns>
                Resultado de la clasificación.
            </returns>
        </member>
        <member name="T:TGC.Core.Collision.TgcCollisionUtils.PlaneBoxResult">
            <summary>
                Resultado de una clasificación Plano-BoundingBox
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.PlaneBoxResult.BEHIND">
            <summary>
                El BoundingBox está completamente en el lado negativo el plano
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.PlaneBoxResult.IN_FRONT_OF">
            <summary>
                El BoundingBox está completamente en el lado positivo del plano
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.PlaneBoxResult.INTERSECT">
            <summary>
                El Plano atraviesa al BoundingBox
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testPlaneAABB(Microsoft.DirectX.Plane,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Indica si un Plano colisiona con un BoundingBox
            </summary>
            <param name="plane">Plano</param>
            <param name="aabb">BoundingBox</param>
            <returns>True si hay colisión.</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testTriangleAABB(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                /// Indica si un Triangulo colisiona con un BoundingBox
                Basado en:
                http://fileadmin.cs.lth.se/cs/Personal/Tomas_Akenine-Moller/code/tribox3.txt
            </summary>
            <param name="vert0">Vertice 0 del triángulo</param>
            <param name="vert1">Vertice 1 del triángulo</param>
            <param name="vert2">Vertice 2 del triángulo</param>
            <param name="aabb">BoundingBox</param>
            <returns>True si hay colisión.</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testTriangleAABB_planeBoxOverlap(System.Single[],System.Single[],System.Single[])">
            <summary>
                Utilizado por testTriangleAABB.
                Indica si un Box colisiona con un plano.
                Adaptado especificamente a la forma que lo utiliza testTriangleAABB.
            </summary>
            <param name="normal">normal del plano</param>
            <param name="vert">un punto del plano</param>
            <param name="maxbox">????</param>
            <returns>true si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testSphereSphere(TGC.Core.BoundingVolumes.TgcBoundingSphere,TGC.Core.BoundingVolumes.TgcBoundingSphere)">
            <summary>
                Indica si un BoundingSphere colisiona con otro.
            </summary>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testSpherePlane(TGC.Core.BoundingVolumes.TgcBoundingSphere,Microsoft.DirectX.Plane)">
            <summary>
                Idica si un BoundingSphere colisiona con un plano
            </summary>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.insideSpherePlane(TGC.Core.BoundingVolumes.TgcBoundingSphere,Microsoft.DirectX.Plane)">
            <summary>
                Indica si un BoundingSphere se encuentra completamente en el lado negativo del plano
            </summary>
            <returns>True si se encuentra completamente en el lado negativo del plano</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectRaySphere(TGC.Core.Geometry.TgcRay,TGC.Core.BoundingVolumes.TgcBoundingSphere,System.Single@,Microsoft.DirectX.Vector3@)">
            <summary>
                Indica si un Ray colisiona con un BoundingSphere.
                Si el resultado es True se carga el punto de colision (q) y la distancia de colision en el Ray (t).
                La dirección del Ray debe estar normalizada.
            </summary>
            <param name="ray">Ray</param>
            <param name="sphere">BoundingSphere</param>
            <param name="t">Distancia de colision del Ray</param>
            <param name="q">Punto de colision</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectSegmentSphere(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingSphere,System.Single@,Microsoft.DirectX.Vector3@)">
            <summary>
                Indica si un segmento de recta colisiona con un BoundingSphere.
                Si el resultado es True se carga el punto de colision (q) y la distancia de colision en el t.
                La dirección del Ray debe estar normalizada.
            </summary>
            <param name="p0">Punto inicial del segmento</param>
            <param name="p1">Punto final del segmento</param>
            <param name="s">BoundingSphere</param>
            <param name="t">Distancia de colision del segmento</param>
            <param name="q">Punto de colision</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testRaySphere(TGC.Core.Geometry.TgcRay,TGC.Core.BoundingVolumes.TgcBoundingSphere)">
            <summary>
                Indica si un BoundingSphere colisiona con un Ray (sin indicar su punto de colision)
                La dirección del Ray debe estar normalizada.
            </summary>
            <param name="ray">Ray</param>
            <param name="sphere">BoundingSphere</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testPointSphere(TGC.Core.BoundingVolumes.TgcBoundingSphere,Microsoft.DirectX.Vector3)">
            <summary>
                Indica si el punto p se encuentra dentro de la esfera
            </summary>
            <param name="sphere">BoundingSphere</param>
            <param name="p">Punto a testear</param>
            <returns>True si p está dentro de la esfera</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectMovingSpherePlane(TGC.Core.BoundingVolumes.TgcBoundingSphere,Microsoft.DirectX.Vector3,Microsoft.DirectX.Plane,System.Single@,Microsoft.DirectX.Vector3@)">
            <summary>
                Detecta colision entre una esfera que se esta moviendo contra un plano.
                Si hay colision devuelve el instante t de la colision y el punto q de colision.
            </summary>
            <param name="sphere">BoundingSphere</param>
            <param name="velocity">Vector de movimiento de la esfera</param>
            <param name="plane">Plano</param>
            <param name="t">Instante de colision en el intervalo [0, 1]</param>
            <param name="q">Punto de colision</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testMovingSpherePlane(TGC.Core.BoundingVolumes.TgcBoundingSphere,Microsoft.DirectX.Vector3,Microsoft.DirectX.Plane)">
            <summary>
                Indica si una esfera que se esta moviendo colisiona contra un plano.
                Solo indica si hay colision. No calcula el punto de colision.
                Es mas eficiente que el metodo: "intersectMovingSpherePlane()"
            </summary>
            <param name="sphere">BoundingSphere</param>
            <param name="velocity">Vector de movimiento de la esfera</param>
            <param name="plane">Plano</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testSphereTriangle(TGC.Core.BoundingVolumes.TgcBoundingSphere,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3@)">
            <summary>
                Indica si un BoundingSphere colisiona con un triangulo (a, b, c).
                Si hay colision devuelve el punto p mas cercano de la colision
            </summary>
            <param name="sphere">BoundingSphere</param>
            <param name="a">Vertice A del triangulo</param>
            <param name="b">Vertice B del triangulo</param>
            <param name="c">Vertice C del triangulo</param>
            <param name="p">Punto mas cercano de colision</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.closestPointPlane(Microsoft.DirectX.Vector3,Microsoft.DirectX.Plane)">
            <summary>
                Determina el punto del plano p mas cercano al punto q.
                La normal del plano puede estar sin normalizar.
            </summary>
            <param name="q">Punto a testear</param>
            <param name="p">Plano</param>
            <returns>Punto del plano que mas cerca esta de q</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.closestPointPlaneNorm(Microsoft.DirectX.Vector3,Microsoft.DirectX.Plane)">
            <summary>
                Determina el punto del plano p mas cercano al punto q.
                Más ágil que closestPointPlane() pero la normal del plano debe estar normalizada.
            </summary>
            <param name="q">Punto a testear</param>
            <param name="p">Plano</param>
            <returns>Punto del plano que mas cerca esta de q</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.distPointPlane(Microsoft.DirectX.Vector3,Microsoft.DirectX.Plane)">
            <summary>
                Indica la distancia de un punto al plano
            </summary>
            <param name="q">Punto a testear</param>
            <param name="p">Plano</param>
            <returns>Distancia del punto al plano</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.classifyPointPlane(Microsoft.DirectX.Vector3,Microsoft.DirectX.Plane)">
            <summary>
                Clasifica un Punto respecto de un Plano
            </summary>
            <param name="q">Punto a clasificar</param>
            <param name="p">Plano</param>
            <returns>Resultado de la colisión</returns>
        </member>
        <member name="T:TGC.Core.Collision.TgcCollisionUtils.PointPlaneResult">
            <summary>
                Resultado de una clasificación Punto-Plano
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.PointPlaneResult.BEHIND">
            <summary>
                El punto está sobre el lado negativo el plano
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.PointPlaneResult.IN_FRONT_OF">
            <summary>
                El punto está sobre el lado positivo del plano
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.PointPlaneResult.COINCIDENT">
            <summary>
                El punto pertenece al plano
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.closestPointSegment(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Single@)">
            <summary>
                Dado el segmento ab y el punto p, determina el punto mas cercano sobre el segmento ab.
            </summary>
            <param name="c">Punto a testear</param>
            <param name="a">Inicio del segmento ab</param>
            <param name="b">Fin del segmento ab</param>
            <param name="t">Valor que cumple la ecuacion d(t) = a + t*(b - a)</param>
            <returns>Punto sobre ab que esta mas cerca de p</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.sqDistPointSegment(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Devuelve la distancia al cuadrado entre el punto c y el segmento ab
            </summary>
            <param name="a">Inicio del segmento ab</param>
            <param name="b">Fin del segmento ab</param>
            <param name="c">Punto a testear</param>
            <returns>Distancia al cuadrado entre c y ab</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectRayPlane(TGC.Core.Geometry.TgcRay,Microsoft.DirectX.Plane,System.Single@,Microsoft.DirectX.Vector3@)">
            <summary>
                Indica si un Ray colisiona con un Plano.
                Tanto la normal del plano como la dirección del Ray se asumen normalizados.
            </summary>
            <param name="ray">Ray a testear</param>
            <param name="plane">Plano a testear</param>
            <param name="t">Instante de colisión</param>
            <param name="q">Punto de colisión con el plano</param>
            <returns>True si hubo colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectSegmentPlane(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Plane,System.Single@,Microsoft.DirectX.Vector3@)">
            <summary>
                Indica si el segmento de recta compuesto por a-b colisiona con el Plano.
                La normal del plano se considera normalizada.
            </summary>
            <param name="a">Punto inicial del segmento</param>
            <param name="b">Punto final del segmento</param>
            <param name="plane">Plano a testear</param>
            <param name="t">Instante de colisión</param>
            <param name="q">Punto de colisión</param>
            <returns>True si hay colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.closestPointTriangle(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Determina el punto mas cercano entre el triángulo (abc) y el punto p.
            </summary>
            <param name="p">Punto a testear</param>
            <param name="a">Vértice A del triángulo</param>
            <param name="b">Vértice B del triángulo</param>
            <param name="c">Vértice C del triángulo</param>
            <returns>Punto mas cercano al triángulo</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.closestPointRectangle3d(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Determina el punto mas cercano entre un rectánglo 3D (especificado por a, b y c) y el punto p.
                Los puntos a, b y c deben formar un rectángulo 3D tal que los vectores AB y AC expandan el rectángulo.
            </summary>
            <param name="p">Punto a testear</param>
            <param name="a">Vértice A del rectángulo</param>
            <param name="b">Vértice B del rectángulo</param>
            <param name="c">Vértice C del rectángulo</param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.closestPoint(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3[],System.Single@)">
            <summary>
                Indica el punto mas cercano a p
            </summary>
            <param name="p">Punto a testear</param>
            <param name="points">Array de puntos del cual se quiere buscar el mas cercano</param>
            <param name="minDistSq">Distancia al cuadrado del punto mas cercano</param>
            <returns>Punto más cercano a p del array</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.classifyFrustumAABB(TGC.Core.BoundingVolumes.TgcFrustum,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Clasifica un BoundingBox respecto del Frustum
            </summary>
            <param name="frustum">Frustum</param>
            <param name="aabb">BoundingBox</param>
            <returns>Resultado de la clasificación</returns>
        </member>
        <member name="T:TGC.Core.Collision.TgcCollisionUtils.FrustumResult">
            <summary>
                Resultado de una colisión entre un objeto y el Frustum
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.FrustumResult.OUTSIDE">
            <summary>
                El objeto se encuentra completamente fuera del Frustum
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.FrustumResult.INSIDE">
            <summary>
                El objeto se encuentra completamente dentro del Frustum
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.FrustumResult.INTERSECT">
            <summary>
                El objeto posee parte fuera y parte dentro del Frustum
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testPointFrustum(TGC.Core.BoundingVolumes.TgcFrustum,Microsoft.DirectX.Vector3)">
            <summary>
                Indica si un Punto colisiona con el Frustum
            </summary>
            <param name="frustum">Frustum</param>
            <param name="p">Punto</param>
            <returns>True si el Punto está adentro del Frustum</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.classifyFrustumSphere(TGC.Core.BoundingVolumes.TgcFrustum,TGC.Core.BoundingVolumes.TgcBoundingSphere)">
            <summary>
                Indica si un BoundingSphere colisiona con el Frustum
            </summary>
            <param name="frustum">Frustum</param>
            <param name="sphere">BoundingSphere</param>
            <returns>Resultado de la colisión</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.classifyConvexPolyhedronAABB(TGC.Core.Geometry.TgcConvexPolyhedron,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Clasifica un BoundingBox respecto de un Cuerpo Convexo.
                Los planos del Cuerpo Convexo deben apuntar hacia adentro.
            </summary>
            <param name="polyhedron">Cuerpo convexo</param>
            <param name="aabb">BoundingBox</param>
            <returns>Resultado de la clasificación</returns>
        </member>
        <member name="T:TGC.Core.Collision.TgcCollisionUtils.ConvexPolyhedronResult">
            <summary>
                Resultado de una colisión entre un objeto y un Cuerpo Convexo
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.ConvexPolyhedronResult.OUTSIDE">
            <summary>
                El objeto se encuentra completamente fuera del Cuerpo Convexo
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.ConvexPolyhedronResult.INSIDE">
            <summary>
                El objeto se encuentra completamente dentro del Cuerpo Convexo
            </summary>
        </member>
        <member name="F:TGC.Core.Collision.TgcCollisionUtils.ConvexPolyhedronResult.INTERSECT">
            <summary>
                El objeto posee parte fuera y parte dentro del Cuerpo Convexo
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.classifyPointConvexPolyhedron(Microsoft.DirectX.Vector3,TGC.Core.Geometry.TgcConvexPolyhedron)">
            <summary>
                Clasifica un punto respecto de un Cuerpo Convexo de N caras.
                Puede devolver OUTSIDE o INSIDE (si es coincidente se considera como INSIDE).
                Los planos del Cuerpo Convexo deben apuntar hacia adentro.
            </summary>
            <param name="q">Punto a clasificar</param>
            <param name="polyhedron">Cuerpo Convexo</param>
            <returns>Resultado de la clasificación</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testPointConvexPolyhedron(Microsoft.DirectX.Vector3,TGC.Core.Geometry.TgcConvexPolyhedron)">
            <summary>
                Indica si un punto se encuentra dentro de un Cuerpo Convexo.
                Los planos del Cuerpo Convexo deben apuntar hacia adentro.
                Es más ágil que llamar a classifyPointConvexPolyhedron()
            </summary>
            <param name="q">Punto a clasificar</param>
            <param name="polyhedron">Cuerpo Convexo</param>
            <returns>True si se encuentra adentro.</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.clipConvexPolygon(Microsoft.DirectX.Vector3[],Microsoft.DirectX.Plane,Microsoft.DirectX.Vector3[]@)">
            <summary>
                Recorta un polígono convexo en 3D por un plano.
                Devuelve el nuevo polígono recortado.
                Algoritmo de Sutherland-Hodgman
            </summary>
            <param name="poly">Vértices del polígono a recortar</param>
            <param name="p">Plano con el cual se recorta</param>
            <param name="clippedPoly">Vértices del polígono recortado></param>
            <returns>True si el polígono recortado es válido. False si está degenerado</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testPointInConvexPolygon(Microsoft.DirectX.Vector3[],Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Indica si un punto en el espacio se encuentra dentro de un poligono convexo.
                El punto debe pertenecer al plano del poligono previamente (este metodo asume que eso ya se testeo antes. Usar
                classifyPointPlane()).
                NO FUNCIONA 100% BIEN
            </summary>
            <param name="polyVertices">Lista de vertices del poligono</param>
            <param name="polyNormal">Normal del poligono</param>
            <param name="q">Punto a testear</param>
            <returns>True si el punto se encuentra dentro del poligono</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectRayConvexPolygon(TGC.Core.Geometry.TgcRay,Microsoft.DirectX.Vector3[],System.Single@,Microsoft.DirectX.Vector3@)">
            <summary>
                Detecta colision entre un rayo y un poligono convexo formado por un conjunto de vertices.
            </summary>
            <param name="ray">Rayo</param>
            <param name="polyVertices">Conjunto de vertices del poligono</param>
            <param name="t">Instante de tiempo de colision</param>
            <param name="q">Punto de colision</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testPointInTriangle(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Indica si un punto p en el espacio se encuentra dentro de un triangulo (a, b, c)
            </summary>
            <param name="p">Punto a probar</param>
            <param name="a">Vertice A del triangulo</param>
            <param name="b">Vertice B del triangulo</param>
            <param name="c">Vertice C del triangulo</param>
            <returns>True si el punto pertenece al triangulo</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectSegmentTriangle(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3@,System.Single@,Microsoft.DirectX.Vector3@)">
            <summary>
                Detecta colision entre un segmento pq y un triangulo abc.
                Devuelve true si hay colision y carga las coordenadas barycentricas (u,v,w) de la colision, el
                instante t de colision y el punto c de colision.
                Basado en: Real Time Collision Detection pag 191
            </summary>
            <param name="p">Inicio del segmento</param>
            <param name="q">Fin del segmento</param>
            <param name="a">Vertice 1 del triangulo</param>
            <param name="b">Vertice 2 del triangulo</param>
            <param name="c">Vertice 3 del triangulo</param>
            <param name="uvw">Coordenadas barycentricas de colision</param>
            <param name="t">Instante de colision</param>
            <param name="col">Punto de colision</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectRayTriangle(TGC.Core.Geometry.TgcRay,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Single@,Microsoft.DirectX.Vector3@)">
            <summary>
                Detecta colision entre un segmento pq y un triangulo abc.
                Devuelve true si hay colision y carga las coordenadas barycentricas (u,v,w) de la colision, el
                instante t de colision y el punto c de colision.
                Basado en paper Tomas Moller: http://en.wikipedia.org/wiki/M%C3%B6ller%E2%80%93Trumbore_intersection_algorithm
            </summary>
            <param name="ray">Ray</param>
            <param name="a">Vertice 1 del triangulo</param>
            <param name="b">Vertice 2 del triangulo</param>
            <param name="c">Vertice 3 del triangulo</param>
            <param name="t">Instante de colision</param>
            <param name="q">Punto de colision</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectLineTriangle(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3@,System.Single@,Microsoft.DirectX.Vector3@)">
            <summary>
                Interseccion entre una Linea pq y un Triangulo abc
                Devuelve true si hay colision y carga las coordenadas barycentricas (u,v,w) de la colision, el
                instante t de colision y el punto c de colision.
                Basado en: Real Time Collision Detection pag 186
            </summary>
            <param name="p">Inicio del segmento</param>
            <param name="q">Fin del segmento</param>
            <param name="a">Vertice 1 del triangulo</param>
            <param name="b">Vertice 2 del triangulo</param>
            <param name="c">Vertice 3 del triangulo</param>
            <param name="uvw">Coordenadas barycentricas de colision</param>
            <param name="t">Instante de colision</param>
            <param name="col">Punto de colision</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testRayCylinder(TGC.Core.Geometry.TgcRay,TGC.Core.BoundingVolumes.TgcBoundingCylinder)">
            <summary>
                Indica si un rayo colisiona con un cilindro.
            </summary>
            <param name="ray">Rayo</param>
            <param name="cylinder">Cilindro orientado</param>
            <returns>True si el rayo colisiona con el cilindro</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testPointCylinder(Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingCylinder)">
            <summary>
                Indica si un Punto colisiona con un Cilindro.
            </summary>
            <param name="p">Punto</param>
            <param name="cylinder">Cilindro</param>
            <returns>True si el Punto esta adentro del Cilindro</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.closestPointCylinder(Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingCylinder)">
            <summary>
                Determina el punto del cilindro mas cercano al punto p.
            </summary>
            <param name="p">Punto</param>
            <param name="cylinder">Cilindro orientable</param>
            <returns>Punto del cilindro que esta mas cerca de p</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testSphereCylinder(TGC.Core.BoundingVolumes.TgcBoundingSphere,TGC.Core.BoundingVolumes.TgcBoundingCylinder)">
            <summary>
                Indica si un Cilindro colisiona con una Esfera.
                Solo indica si hay colision o no. No va mas en detalle.
            </summary>
            <param name="sphere">Esfera</param>
            <param name="cylinder">Cilindro orientable</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectSegmentCylinder(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingCylinder,System.Single@,Microsoft.DirectX.Vector3@)">
            <summary>
                Indica si un cilindro colisiona con un segmento.
                El cilindro se especifica con dos puntos centrales "cylinderInit" y "cylinderEnd" que forman una recta y con un
                radio "radius".
                Si hay colision se devuelve el instante de colision "t" y el punto de colision "q"
            </summary>
            <param name="segmentInit">Punto de inicio del segmento</param>
            <param name="segmentEnd">Punto de fin del segmento</param>
            <param name="cylinderInit">Punto inicial del cilindro</param>
            <param name="cylinderEnd">Punto final del cilindro</param>
            <param name="radius">Radio del cilindro</param>
            <param name="t">Instante de colision</param>
            <param name="q">Punto de colision</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testRayCylinder(TGC.Core.Geometry.TgcRay,TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY)">
            <summary>
                Indica si un rayo colisiona con un cilindro.
            </summary>
            <param name="ray">Rayo</param>
            <param name="cylinder">Cilindro alineado</param>
            <returns>True si el rayo colisiona con el cilindro</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testPointCylinder(Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY)">
            <summary>
                Indica si un Punto colisiona con un Cilindro.
            </summary>
            <param name="p">Punto</param>
            <param name="cylinder">Cilindro alineado</param>
            <returns>True si el Punto esta adentro del Cilindro</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.closestPointCylinder(Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY)">
            <summary>
                Determina el punto mas cercano de un cilindro al punto P especificado
            </summary>
            <param name="p">Punto</param>
            <param name="cylinder">Cilindro alineado</param>
            <returns>Punto perteneciente al cilindro mas cercano a P</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testSphereCylinder(TGC.Core.BoundingVolumes.TgcBoundingSphere,TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY)">
            <summary>
                Indica si un Cilindro colisiona con una Esfera.
                Solo indica si hay colision o no. No va mas en detalle.
            </summary>
            <param name="sphere">Esfera</param>
            <param name="cylinder">Cilindro alineado</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testAABBCylinder(TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox,TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY)">
            <summary>
                Indica si un Cilindro colisiona con un AABB.
                Solo indica si hay colision o no. No va mas en detalle.
            </summary>
            <param name="box">AABB</param>
            <param name="cylinder">Cilindro alineado</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testCylinderCylinder(TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY,TGC.Core.BoundingVolumes.TgcBoundingCylinderFixedY)">
            <summary>
                Indica si un Cilindro colisiona con otro Cilindro.
                Solo indica si hay colision o no. No va mas en detalle.
            </summary>
            <param name="collider">Cilindro alineado que genera la colision</param>
            <param name="collisionable">Cilindro alineado estatico</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testRayCylinder(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Indica si un rayo colisiona con el cilindro de radio 1, altura 2, y centro en el origen de coordenadas.
            </summary>
            <param name="origin">Origen del rayo</param>
            <param name="direction">Vector director del rayo</param>
            <returns>True si el rayo colisiona con el cilindro</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testPointCylinder(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Single,System.Single)">
            <summary>
                Indica si un Punto colisiona con un Cilindro.
            </summary>
            <param name="p">Punto</param>
            <param name="cylCenter">Centro o posicion del cilindro</param>
            <param name="cylHalfLength">Media altura del cilindro</param>
            <param name="cylRadius">Radio del cilindro</param>
            <returns>True si el Punto esta adentro del Cilindro</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.closestPointCylinder(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,System.Single,System.Single)">
            <summary>
                Determina el punto mas cercano de un cilindro al punto P especificado
            </summary>
            <param name="p">Punto</param>
            <param name="cylCenter">Centro o posicion del cilindro</param>
            <param name="cylHalfLength">Media altura del cilindro</param>
            <param name="cylRadius">Radio del cilindro</param>
            <returns>Punto perteneciente al cilindro mas cercano a P</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testSphereCylinder(Microsoft.DirectX.Vector3,System.Single,Microsoft.DirectX.Vector3,System.Single,System.Single)">
            <summary>
                Indica si un Cilindro colisiona con una Esfera.
                Solo indica si hay colision o no. No va mas en detalle.
            </summary>
            <param name="sphere">Esfera</param>
            <param name="cylCenter">Centro o posicion del cilindro</param>
            <param name="cylHalfLength">Media altura del cilindro</param>
            <param name="cylRadius">Radio del cilindro</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testObbObb(TGC.Core.BoundingVolumes.TgcBoundingOrientedBox,TGC.Core.BoundingVolumes.TgcBoundingOrientedBox)">
            <summary>
                Testear si hay olision entre dos OBB
            </summary>
            <param name="a">Primer OBB</param>
            <param name="b">Segundo OBB</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testObbObb(TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.OBBStruct,TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.OBBStruct)">
            <summary>
                Testear si hay olision entre dos OBB
            </summary>
            <param name="a">Primer OBB</param>
            <param name="b">Segundo OBB</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.intersectRayObb(TGC.Core.Geometry.TgcRay,TGC.Core.BoundingVolumes.TgcBoundingOrientedBox,Microsoft.DirectX.Vector3@)">
            <summary>
                Interseccion Ray-OBB.
                Devuelve true y el punto q de colision si hay interseccion.
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testObbAABB(TGC.Core.BoundingVolumes.TgcBoundingOrientedBox,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox)">
            <summary>
                Testear si hay olision entre un OBB y un AABB
            </summary>
            <param name="a">OBB</param>
            <param name="b">AABB</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.testObbAABB(TGC.Core.BoundingVolumes.TgcBoundingOrientedBox.OBBStruct,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox.AABBStruct)">
            <summary>
                Testear si hay olision entre un OBB y un AABB
            </summary>
            <param name="a">OBB</param>
            <param name="b">AABB</param>
            <returns>True si hay colision</returns>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.toVector3(Microsoft.DirectX.Plane)">
            <summary>
                Crea un vector en base a los valores A, B y C de un plano
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.toArray(Microsoft.DirectX.Vector3)">
            <summary>
                Crea un array de floats con X,Y,Z
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.toVector3(System.Single[])">
            <summary>
                Crea un vector en base a un array de floats con X,Y,Z
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.swap(System.Single@,System.Single@)">
            <summary>
                Invierte el valor de dos floats
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.getPlaneNormal(Microsoft.DirectX.Plane)">
            <summary>
                Devuelve un Vector3 con la normal del plano (sin normalizar)
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.max(System.Single,System.Single)">
            <summary>
                Devuelve el mayor valor
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.max(System.Single,System.Single,System.Single)">
            <summary>
                Devuelve el mayor valor
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.min(System.Single,System.Single)">
            <summary>
                Devuelve el menor valor
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.min(System.Single,System.Single,System.Single)">
            <summary>
                Devuelve el menor valor
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.findMinMax(System.Single,System.Single,System.Single,System.Single@,System.Single@)">
            <summary>
                Devuelve el menor y mayor valor de los tres
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.dot(System.Single[],System.Single[])">
            <summary>
                Dot product entre dos float[3]
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.sameSign(System.Single,System.Single)">
            <summary>
                Compara el signo de dos float.
                Devuelve TRUE si tienen el mismo signo.
            </summary>
        </member>
        <member name="M:TGC.Core.Collision.TgcCollisionUtils.scalarTriple(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Expresion: (u x v) . w
                Devuelve un escalar
            </summary>
        </member>
        <member name="T:TGC.Core.HighResolutionTimer">
            <summary>
                High resolution game timer.
            </summary>
        </member>
        <member name="P:TGC.Core.HighResolutionTimer.Frequency">
            <summary>
                Gets the frequency that all timers performs at.
            </summary>
        </member>
        <member name="P:TGC.Core.HighResolutionTimer.Ticks">
            <summary>
                Gets the current system ticks.
            </summary>
        </member>
        <member name="P:TGC.Core.HighResolutionTimer.FrameTime">
            <summary>
                Gets the time recorded between frames.
            </summary>
        </member>
        <member name="P:TGC.Core.HighResolutionTimer.FramesPerSecond">
            <summary>
                Gets the frames per second based on the time between frames.
            </summary>
        </member>
        <member name="M:TGC.Core.HighResolutionTimer.QueryPerformanceCounter(System.Int64@)">
            <summary>
                The current system ticks (count).
            </summary>
            <param name="lpPerformanceCount">Current performance count of the system.</param>
            <returns>False on failure.</returns>
        </member>
        <member name="M:TGC.Core.HighResolutionTimer.QueryPerformanceFrequency(System.Int64@)">
            <summary>
                Ticks per second (frequency) that the high performance counter performs.
            </summary>
            <param name="lpFrequency">Frequency the higher performance counter performs.</param>
            <returns>False if the high performance counter is not supported.</returns>
        </member>
        <member name="M:TGC.Core.HighResolutionTimer.Reset">
            <summary>
                Resets the timer for a new game.
            </summary>
        </member>
        <member name="M:TGC.Core.HighResolutionTimer.Set">
            <summary>
                Calculates frame time since last call to Set.
            </summary>
        </member>
        <member name="T:TGC.Core.Input.TgcD3dInput">
            <summary>
                Manejo de DirectInput para Keyboard y Mouse
            </summary>
        </member>
        <member name="T:TGC.Core.Input.TgcD3dInput.MouseButtons">
            <summary>
                Botones del mouse para DirectInput
            </summary>
        </member>
        <member name="M:TGC.Core.Input.TgcD3dInput.performMouseFiltering(System.Int32,System.Int32)">
            <summary>
                Filter the relative mouse movement based on a weighted sum of the mouse
                movement from previous frames to ensure that the mouse movement this
                frame is smooth.
            </summary>
        </member>
        <member name="M:TGC.Core.Input.TgcD3dInput.performMouseSmoothing(System.Single,System.Single)">
            <summary>
                Average the mouse movement across a couple of frames to smooth out mouse movement.
            </summary>
        </member>
        <member name="M:TGC.Core.Input.TgcD3dInput.keyDown(Microsoft.DirectX.DirectInput.Key)">
            <summary>
                Informa si una tecla se encuentra presionada
            </summary>
        </member>
        <member name="M:TGC.Core.Input.TgcD3dInput.keyUp(Microsoft.DirectX.DirectInput.Key)">
            <summary>
                Informa si una tecla se dejo de presionar
            </summary>
        </member>
        <member name="M:TGC.Core.Input.TgcD3dInput.keyPressed(Microsoft.DirectX.DirectInput.Key)">
            <summary>
                Informa si una tecla se presiono y luego se libero
            </summary>
        </member>
        <member name="M:TGC.Core.Input.TgcD3dInput.buttonDown(TGC.Core.Input.TgcD3dInput.MouseButtons)">
            <summary>
                Informa si un boton del mouse se encuentra presionado
            </summary>
        </member>
        <member name="M:TGC.Core.Input.TgcD3dInput.buttonUp(TGC.Core.Input.TgcD3dInput.MouseButtons)">
            <summary>
                Informa si un boton del mouse se dejo de presionar
            </summary>
        </member>
        <member name="M:TGC.Core.Input.TgcD3dInput.buttonPressed(TGC.Core.Input.TgcD3dInput.MouseButtons)">
            <summary>
                Informa si un boton del mouse se presiono y luego se libero
            </summary>
        </member>
        <member name="P:TGC.Core.Input.TgcD3dInput.EnableMouseSmooth">
            <summary>
                Habilitar Mouse Smooth
            </summary>
        </member>
        <member name="P:TGC.Core.Input.TgcD3dInput.WeightModifier">
            <summary>
                Influencia para filtrar el movimiento del mouse
            </summary>
        </member>
        <member name="P:TGC.Core.Input.TgcD3dInput.XposRelative">
            <summary>
                Desplazamiento relativo de X del mouse
            </summary>
        </member>
        <member name="P:TGC.Core.Input.TgcD3dInput.YposRelative">
            <summary>
                Desplazamiento relativo de Y del mouse
            </summary>
        </member>
        <member name="P:TGC.Core.Input.TgcD3dInput.Xpos">
            <summary>
                Posicion absoluta de X del mouse
            </summary>
        </member>
        <member name="P:TGC.Core.Input.TgcD3dInput.Ypos">
            <summary>
                Posicion absoluta de Y del mouse
            </summary>
        </member>
        <member name="P:TGC.Core.Input.TgcD3dInput.WheelPos">
            <summary>
                Rueda del Mouse
            </summary>
        </member>
        <member name="T:TGC.Core.Interpolation.InterpoladorLineal">
            <summary>
                Utilidad para interpolar un valor que arranca en INIT y va hasta END, a una velocidad determinada.
                El metodo isEnd() indica si termino.
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.InterpoladorLineal.Init">
            <summary>
                Valor inicial
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.InterpoladorLineal.Current">
            <summary>
                Valor actual
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.InterpoladorLineal.End">
            <summary>
                Valor final
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.InterpoladorLineal.Speed">
            <summary>
                Velocidad de incremento en segundos
            </summary>
        </member>
        <member name="M:TGC.Core.Interpolation.InterpoladorLineal.reset">
            <summary>
                Cargar valores iniciales del interpolador
            </summary>
        </member>
        <member name="M:TGC.Core.Interpolation.InterpoladorLineal.update(System.Single)">
            <summary>
                Interpolar y devolver incremento.
                Llamar a reset() la primera vez.
            </summary>
            <returns>Valor actual</returns>
        </member>
        <member name="M:TGC.Core.Interpolation.InterpoladorLineal.isEnd">
            <summary>
                Indica si el interpolador llego al final
            </summary>
        </member>
        <member name="T:TGC.Core.Interpolation.InterpoladorVaiven">
            <summary>
                Utilidad para interpolar linealmente un valor entre un MIN y un MAX, variando en forma de vaiven (subi y baja)
                a una velocidad determinada.
                Nunca termina
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.InterpoladorVaiven.Min">
            <summary>
                Valor minimo
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.InterpoladorVaiven.Max">
            <summary>
                Valor maximo
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.InterpoladorVaiven.Speed">
            <summary>
                Velocidad de incremento en segundos
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.InterpoladorVaiven.Current">
            <summary>
                Valor actual
            </summary>
        </member>
        <member name="M:TGC.Core.Interpolation.InterpoladorVaiven.reset">
            <summary>
                Cargar valores iniciales del interpolador
            </summary>
        </member>
        <member name="M:TGC.Core.Interpolation.InterpoladorVaiven.update(System.Single)">
            <summary>
                Interpolar y devolver incremento.
                Llamar a reset() la primera vez.
                <returns>Valor actual</returns>
            </summary>
        </member>
        <member name="T:TGC.Core.Interpolation.Position2dInterpolator">
            <summary>
                Utilidad para interpolar linealmente entre dos posiciones 2D
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.Position2dInterpolator.Speed">
            <summary>
                Velocidad de desplazamiento en segundos
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.Position2dInterpolator.Init">
            <summary>
                Posicion inicial
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.Position2dInterpolator.End">
            <summary>
                Posicion final
            </summary>
        </member>
        <member name="M:TGC.Core.Interpolation.Position2dInterpolator.reset">
            <summary>
                Cargar valores iniciales del interpolador
            </summary>
        </member>
        <member name="M:TGC.Core.Interpolation.Position2dInterpolator.update(System.Single)">
            <summary>
                Actualizar estado del interpolador.
                Llamar a reset() la primera vez.
            </summary>
            <returns>Nueva posicion</returns>
        </member>
        <member name="M:TGC.Core.Interpolation.Position2dInterpolator.isEnd">
            <summary>
                Indica si el interpolador llego al final
            </summary>
        </member>
        <member name="T:TGC.Core.Interpolation.Temporizador">
            <summary>
                Utilidad para controlar el avance del tiempo hasta un tope determinado (como una cuenta regresiva)
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.Temporizador.Current">
            <summary>
                Valor actual
            </summary>
        </member>
        <member name="P:TGC.Core.Interpolation.Temporizador.StopSegs">
            <summary>
                Fin de la cuenta regresiva, en segundos.
            </summary>
        </member>
        <member name="M:TGC.Core.Interpolation.Temporizador.reset">
            <summary>
                Cargar valores iniciales del temporizador
            </summary>
        </member>
        <member name="M:TGC.Core.Interpolation.Temporizador.update(System.Single)">
            <summary>
                Avanzar el tiempo
            </summary>
            <returns>True si llego a su fin</returns>
        </member>
        <member name="T:TGC.Core.KeyFrameLoader.OriginalData">
            <summary>
                Informacion del MeshData original que hay que guardar para poder alterar el VertexBuffer con la animacion
            </summary>
        </member>
        <member name="T:TGC.Core.KeyFrameLoader.TgcKeyFrameAnimation">
            <summary>
                Animación de una malla animada por KeyFrames
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameAnimation.BoundingBox">
            <summary>
                BoundingBox de la animación
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameAnimation.Data">
            <summary>
                Datos de vértices de la animación
            </summary>
        </member>
        <member name="T:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader">
            <summary>
                Herramienta para cargar una Malla con animacion por KeyFrame, segun formato TGC
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.loadMeshFromFile(System.String,System.String)">
            <summary>
                Carga un modelo a partir de un archivo
            </summary>
            <param name="filePath">Ubicacion del archivo XML</param>
            <param name="mediaPath">Path a partir del cual hay que buscar las Texturas</param>
            <returns>Modelo cargado</returns>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.loadMeshFromFile(System.String)">
            <summary>
                Carga un modelo a partir de un archivo.
                Se elige el directorio de texturas y recursos en base al directorio en el cual se encuntra el archivo del modelo.
            </summary>
            <param name="filePath">Ubicacion del archivo XML</param>
            <returns>Modelo cargado</returns>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.loadMeshAndAnimationsFromFile(System.String,System.String,System.String[])">
            <summary>
                Carga un modelo y un conjunto de animaciones a partir de varios archivos
            </summary>
            <param name="meshFilePath">Ubicacion del archivo XML del modelo</param>
            <param name="mediaPath">Path a partir del cual hay que buscar las Texturas</param>
            <param name="animationsFilePath">Array con ubicaciones de los archivos XML de cada animación</param>
            <returns>Modelo cargado con sus animaciones</returns>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.loadMeshAndAnimationsFromFile(System.String,System.String[])">
            <summary>
                Carga un modelo y un conjunto de animaciones a partir de varios archivos.
                Se elige el directorio de texturas y recursos en base al directorio en el cual se encuntra el archivo del modelo.
            </summary>
            <param name="meshFilePath">Ubicacion del archivo XML del modelo</param>
            <param name="animationsFilePath">Array con ubicaciones de los archivos XML de cada animación</param>
            <returns>Modelo cargado con sus animaciones</returns>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.loadMeshFromString(System.String,System.String)">
            <summary>
                Carga un modelo a partir del string del XML
            </summary>
            <param name="xmlString">contenido del XML</param>
            <param name="mediaPath">Path a partir del cual hay que buscar las Texturas</param>
            <returns>Modelo cargado</returns>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.loadAnimationFromFile(TGC.Core.KeyFrameLoader.TgcKeyFrameMesh,System.String)">
            <summary>
                Carga una animación a un modelo ya cargado, en base a un archivo
                La animación se agrega al modelo.
            </summary>
            <param name="mesh">Modelo ya cargado</param>
            <param name="filePath">Ubicacion del archivo XML de la animación</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.loadAnimationFromString(TGC.Core.KeyFrameLoader.TgcKeyFrameMesh,System.String)">
            <summary>
                Carga una animación a un modelo ya cargado, a partir del string del XML.
                La animación se agrega al modelo.
            </summary>
            <param name="mesh">Modelo ya cargado</param>
            <param name="xmlString">contenido del XML</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.loadAnimation(TGC.Core.KeyFrameLoader.TgcKeyFrameMesh,TGC.Core.KeyFrameLoader.TgcKeyFrameAnimationData)">
            <summary>
                Carga una animación a un modelo ya cargado, a partir de un objeto TgcKeyFrameAnimationData ya parseado
                La animación se agrega al modelo.
            </summary>
            <param name="mesh">Modelo ya cargado</param>
            <param name="animationData">Objeto de animacion con datos ya cargados</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.loadMesh(TGC.Core.KeyFrameLoader.TgcKeyFrameMeshData,System.String)">
            <summary>
                Carga un Modelo a partir de un objeto TgcKeyFrameMeshData ya parseado
            </summary>
            <param name="meshData">Objeto con datos ya parseados</param>
            <param name="mediaPath">Path a partir del cual hay que buscar las Texturas</param>
            <returns>Modelo cargado</returns>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.crearMeshDiffuseMap(TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.TgcKeyFrameLoaderMaterialAux[],TGC.Core.KeyFrameLoader.TgcKeyFrameMeshData)">
            <summary>
                Crea un mesh con uno o varios DiffuseMap
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.crearMeshSoloColor(TGC.Core.KeyFrameLoader.TgcKeyFrameMeshData)">
            <summary>
                Crea un mesh sin texturas, solo con VertexColors
            </summary>
            <param name="meshData"></param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.createTextureAndMaterial(TGC.Core.SceneLoader.TgcMaterialData,System.String)">
            <summary>
                Crea Material y Textura
            </summary>
        </member>
        <member name="T:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.TgcKeyFrameLoaderMaterialAux">
            <summary>
                Estructura auxiliar para cargar SubMaterials y Texturas
            </summary>
        </member>
        <member name="F:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.VertexColorVertexElements">
            <summary>
                FVF para formato de malla VERTEX_COLOR
            </summary>
        </member>
        <member name="T:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.VertexColorVertex">
            <summary>
                Estructura de Vertice para formato de malla VERTEX_COLOR
            </summary>
        </member>
        <member name="F:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.DiffuseMapVertexElements">
            <summary>
                FVF para formato de malla DIFFUSE_MAP
            </summary>
        </member>
        <member name="T:TGC.Core.KeyFrameLoader.TgcKeyFrameLoader.DiffuseMapVertex">
            <summary>
                Estructura de Vertice para formato de malla DIFFUSE_MAP
            </summary>
        </member>
        <member name="T:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh">
            <summary>
                Malla que representa un modelo 3D con varias animaciones, animadas por KeyFrame Animation
            </summary>
        </member>
        <member name="T:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.MeshRenderType">
            <summary>
                Tipos de de renderizado de mallas
            </summary>
        </member>
        <member name="F:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.MeshRenderType.VERTEX_COLOR">
            <summary>
                Solo colores por vertice
            </summary>
        </member>
        <member name="F:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.MeshRenderType.DIFFUSE_MAP">
            <summary>
                Solo un canal de textura en DiffuseMap
            </summary>
        </member>
        <member name="F:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.d3dMesh">
            <summary>
                Mesh de DirectX
            </summary>
        </member>
        <member name="F:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.originalData">
            <summary>
                Informacion del MeshData original que hay que guardar para poder alterar el VertexBuffer con la animacion
            </summary>
        </member>
        <member name="F:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.staticMeshBoundingBox">
            <summary>
                BoundingBox de la malla sin ninguna animación.
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.#ctor(Microsoft.DirectX.Direct3D.Mesh,System.String,TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.MeshRenderType,TGC.Core.KeyFrameLoader.OriginalData)">
            <summary>
                Crea una nueva malla.
            </summary>
            <param name="mesh">Mesh de DirectX</param>
            <param name="renderType">Formato de renderizado de la malla</param>
            <param name="coordinatesIndices">Datos parseados de la malla</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.#ctor(System.String,TGC.Core.KeyFrameLoader.TgcKeyFrameMesh,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una nueva malla que es una instancia de otra malla original.
                Reutiliza toda la geometría de la malla original sin duplicarla.
                Debe crearse luego de haber cargado todas las animaciones en la malla original
            </summary>
            <param name="name">Nombre de la malla</param>
            <param name="parentInstance">Malla original desde la cual basarse</param>
            <param name="translation">Traslación respecto de la malla original</param>
            <param name="rotation">Rotación respecto de la malla original</param>
            <param name="scale">Escala respecto de la malla original</param>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.D3dMesh">
            <summary>
                Mesh interna de DirectX
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.Animations">
            <summary>
                Mapa de animaciones de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.Name">
            <summary>
                Nombre de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.Materials">
            <summary>
                Array de Materials
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.DiffuseMaps">
            <summary>
                Array de texturas para DiffuseMap
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.Enabled">
            <summary>
                Indica si la malla esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.BoundingBox">
            <summary>
                BoundingBox del Mesh.
                Puede variar según la animación que tiene configurada en el momento.
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.RenderType">
            <summary>
                Tipo de formato de Render de esta malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.VertexDeclaration">
            <summary>
                VertexDeclaration del Flexible Vertex Format (FVF) usado por la malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.AutoUpdateBoundingBox">
            <summary>
                Indica si se actualiza automaticamente el BoundingBox con cada movimiento de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.CurrentAnimation">
            <summary>
                Animación actual de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.FrameRate">
            <summary>
                Velocidad de la animacion medida en cuadros por segundo.
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.CurrentFrame">
            <summary>
                Cuadro actual de animacion
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.IsAnimating">
            <summary>
                Indica si actualmente hay una animación en curso.
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.PlayLoop">
            <summary>
                Indica si la animación actual se ejecuta con un Loop
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.ParentInstance">
            <summary>
                Original desde el cual esta malla fue clonada.
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.MeshInstances">
            <summary>
                Lista de mallas que fueron clonadas a partir de este original
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.NumberTriangles">
            <summary>
                Cantidad de triángulos de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.NumberVertices">
            <summary>
                Cantidad de vértices de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.render">
            <summary>
                Renderiza la malla, si esta habilitada.
                Para que haya animacion se tiene que haber seteado una y haber
                llamado previamente al metodo updateAnimation()
                Sino se renderiza la pose fija de la malla
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.dispose">
            <summary>
                Libera los recursos de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.Transform">
            <summary>
                Matriz final que se utiliza para aplicar transformaciones a la malla.
                Si la propiedad AutoTransformEnable esta en True, la matriz se reconstruye en cada cuadro
                en base a los valores de: Position, Rotation, Scale.
                Si AutoTransformEnable está en False, se respeta el valor que el usuario haya cargado en la matriz.
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.AutoTransformEnable">
            <summary>
                En True hace que la matriz de transformacion (Transform) de la malla se actualiza en
                cada cuadro en forma automática, según los valores de: Position, Rotation, Scale.
                En False se respeta lo que el usuario haya cargado a mano en la matriz.
                Por default está en False.
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.Position">
            <summary>
                Posicion absoluta de la Malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.Rotation">
            <summary>
                Rotación absoluta de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.Scale">
            <summary>
                Escalado absoluto de la malla;
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.move(Microsoft.DirectX.Vector3)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.move(System.Single,System.Single,System.Single)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.moveOrientedY(System.Single)">
            <summary>
                Mueve la malla en base a la orientacion actual de rotacion.
                Es necesario rotar la malla primero
            </summary>
            <param name="movement">Desplazamiento. Puede ser positivo (hacia adelante) o negativo (hacia atras)</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.getPosition(Microsoft.DirectX.Vector3)">
            <summary>
                Obtiene la posicion absoluta de la malla, recibiendo un vector ya creado para
                almacenar el resultado
            </summary>
            <param name="pos">Vector ya creado en el que se carga el resultado</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.rotateX(System.Single)">
            <summary>
                Rota la malla respecto del eje X
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.rotateY(System.Single)">
            <summary>
                Rota la malla respecto del eje Y
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.rotateZ(System.Single)">
            <summary>
                Rota la malla respecto del eje Z
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.initData(Microsoft.DirectX.Direct3D.Mesh,System.String,TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.MeshRenderType,TGC.Core.KeyFrameLoader.OriginalData)">
            <summary>
                Cargar datos iniciales
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.playAnimation(System.String,System.Boolean,System.Single)">
            <summary>
                Establece cual es la animacion activa de la malla.
                Si la animacion activa es la misma que ya esta siendo animada actualmente, no se para ni se reinicia.
                Para forzar que se reinicie es necesario hacer stopAnimation()
            </summary>
            <param name="animationName">Nombre de la animacion a activar</param>
            <param name="playLoop">Indica si la animacion vuelve a comenzar al terminar</param>
            <param name="userFrameRate">FrameRate personalizado. Con -1 se utiliza el default de la animación</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.playAnimation(System.String,System.Boolean)">
            <summary>
                Establece cual es la animacion activa de la malla.
                Si la animacion activa es la misma que ya esta siendo animada actualmente, no se para ni se reinicia.
                Para forzar que se reinicie es necesario hacer stopAnimation().
                Utiliza el FrameRate default de cada animación
            </summary>
            <param name="animationName">Nombre de la animacion a activar</param>
            <param name="playLoop">Indica si la animacion vuelve a comenzar al terminar</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.playAnimation(System.String)">
            <summary>
                Establece cual es la animacion activa de la malla.
                Si la animacion activa es la misma que ya esta siendo animada actualmente, no se para ni se reinicia.
                Para forzar que se reinicie es necesario hacer stopAnimation().
                Se reproduce con loop.
                Utiliza el FrameRate default de cada animación
            </summary>
            <param name="animationName">Nombre de la animacion a activar</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.initAnimationSettings(System.String,System.Boolean,System.Single)">
            <summary>
                Prepara una nueva animacion para ser ejecutada
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.stopAnimation">
            <summary>
                Desactiva la animacion actual
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.updateAnimation(System.Single)">
            <summary>
                Actualiza el cuadro actual de la animacion.
                Debe ser llamado en cada cuadro antes de Render()
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.fillVertexBufferData(System.Single[])">
            <summary>
                Llena la informacion del VertexBuffer con los vertices especificados
            </summary>
            <param name="verticesCoordinates"></param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.getCurrentFrame">
            <summary>
                Devuelve el cuadro actual de animacion
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.setShaderMatrix">
            <summary>
                Cargar todas la matrices que necesita el shader
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.updateMeshTransform">
            <summary>
                Aplicar transformaciones del mesh
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.activateAlphaBlend">
            <summary>
                Activar AlphaBlending, si corresponde
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.resetAlphaBlend">
            <summary>
                Desactivar AlphaBlending
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.animateAndRender(System.Single)">
            <summary>
                Actualiza el cuadro actual de animacion y renderiza la malla.
                Es equivalente a llamar a updateAnimation() y luego a Render()
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.getVertexPositions">
            <summary>
                Devuelve un array con todas las posiciones de los vértices de la malla, en el estado actual
            </summary>
            <returns>Array creado</returns>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.createBoundingBox">
            <summary>
                Calcula el BoundingBox de la malla, en base a todos sus vertices.
                Llamar a este metodo cuando ha cambiado la estructura interna de la malla.
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.updateBoundingBox">
            <summary>
                Actualiza el BoundingBox de la malla, en base a su posicion actual.
                Solo contempla traslacion y escalado
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.setColor(System.Drawing.Color)">
            <summary>
                Cambia el color de todos los vértices de la malla.
                En modelos complejos puede resultar una operación poco performante.
                La actualización será visible la próxima vez que se haga updateAnimation()
                Si hay instnacias de este modelo, sea el original o una copia, todos los demás se verán
                afectados
            </summary>
            <param name="color">Color nuevo</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.changeDiffuseMaps(TGC.Core.Textures.TgcTexture[])">
            <summary>
                Permite cambiar las texturas de DiffuseMap de esta malla
            </summary>
            <param name="newDiffuseMaps">Array de nuevas texturas. Tiene que tener la misma cantidad que el original</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.createMeshInstance(System.String,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una nueva malla que es una instancia de esta malla original
                Reutiliza toda la geometría de la malla original sin duplicarla.
                Solo se puede crear instancias a partir de originales.
                Se debe crear después de haber agregado todas las animaciones al original.
            </summary>
            <param name="name">Nombre de la malla</param>
            <param name="translation">Traslación respecto de la malla original</param>
            <param name="rotation">Rotación respecto de la malla original</param>
            <param name="scale">Escala respecto de la malla original</param>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.createMeshInstance(System.String)">
            <summary>
                Crea una nueva malla que es una instancia de esta malla original
                Reutiliza toda la geometría de la malla original sin duplicarla.
                Solo se puede crear instancias a partir de originales.
                Se debe crear después de haber agregado todas las animaciones al original.
            </summary>
            <param name="name">Nombre de la malla</param>
        </member>
        <member name="T:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.AnimationEndsHandler">
            <summary>
                Indica que la animación actual ha finalizado.
                Se llama cuando se acabaron los frames de la animación.
                Si se anima en Loop, se llama cada vez que termina.
            </summary>
            <param name="mesh">Malla animada</param>
        </member>
        <member name="E:TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.AnimationEnds">
            <summary>
                Evento que se llama cada vez que la animación actual finaliza.
                Se llama cuando se acabaron los frames de la animación.
                Si se anima en Loop, se llama cada vez que termina.
            </summary>
        </member>
        <member name="T:TGC.Core.KeyFrameLoader.TgcKeyFrameParser">
            <summary>
                Parser de XML de mesh animado por KeyFrame creado con plugin TgcKeyFrameExporter.ms de 3DsMax
            </summary>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameParser.parseMeshFromString(System.String)">
            <summary>
                Levanta la informacion del mesh a partir de un XML
            </summary>
            <param name="xmlString">contenido del XML</param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.KeyFrameLoader.TgcKeyFrameParser.parseAnimationFromString(System.String)">
            <summary>
                Levanta la informacion de una animacion a partir del XML
            </summary>
            <param name="xmlString">Contenido que el XML</param>
        </member>
        <member name="T:TGC.Core.Particle.ColaDeParticulas">
            <summary>
                Pila para almacenar particulas
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.ColaDeParticulas.Count">
            <summary>
                Cantidad actual de elementos
            </summary>
        </member>
        <member name="T:TGC.Core.Particle.Particle">
            <summary>
                Particula a ser emitida por el emisor de particulas
            </summary>
        </member>
        <member name="F:TGC.Core.Particle.Particle.ParticleVertexElements">
            <summary>
                FVF para formato de vertice de Particula
            </summary>
        </member>
        <member name="F:TGC.Core.Particle.Particle.DEFAULT_COLOR">
            <summary>
                Color default de particula
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.Particle.TotalTimeToLive">
            <summary>
                Tiempo total de vida de la particula
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.Particle.TimeToLive">
            <summary>
                Tiempo que le queda de vida a la particula
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.Particle.Speed">
            <summary>
                Velocidad de la particula
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.Particle.PointSprite">
            <summary>
                Vertice de la particula
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.Particle.Position">
            <summary>
                Posicion de la particula
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.Particle.Color">
            <summary>
                Color de la particula
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.Particle.PointSize">
            <summary>
                Tamaño de la particula
            </summary>
        </member>
        <member name="T:TGC.Core.Particle.Particle.ParticleVertex">
            <summary>
                Estructura de Vertice para Particula
            </summary>
        </member>
        <member name="T:TGC.Core.Particle.ParticleEmitter">
            <summary>
                Emisor de particulas para generar efectos de particulas
            </summary>
        </member>
        <member name="M:TGC.Core.Particle.ParticleEmitter.#ctor(System.String,System.Int32)">
            <summary>
                Crear un emisor de particulas
            </summary>
            <param name="texturePath">textura a utilizar</param>
            <param name="particlesCount">cantidad maxima de particlas a generar</param>
        </member>
        <member name="P:TGC.Core.Particle.ParticleEmitter.Enabled">
            <summary>
                Habilita o deshabilita el emisor
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.ParticleEmitter.Playing">
            <summary>
                Iniciar o parar la generacion de nuevas particulas
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.ParticleEmitter.Position">
            <summary>
                Posicion del emisor de particulas en la escena.
                Todas las particulas se generan en esta posicion.
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.ParticleEmitter.CreationFrecuency">
            <summary>
                Tiempo de frecuencia de creacion de particulas.
                Cuanto mas chico mas rapido.
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.ParticleEmitter.ParticleTimeToLive">
            <summary>
                Tiempo de vida de las particulas.
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.ParticleEmitter.MinSizeParticle">
            <summary>
                Minimo tamaño que puede tener una particula.
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.ParticleEmitter.MaxSizeParticle">
            <summary>
                Maximo tamaño que puede tener una particula.
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.ParticleEmitter.Dispersion">
            <summary>
                Valor que representa el grado de dispersion de las particulas.
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.ParticleEmitter.Speed">
            <summary>
                Vector que se le multiplica a la velocidad base (Por defecto es (1,1,1)).
                Si Y es negativo las particulas descienden.
            </summary>
        </member>
        <member name="P:TGC.Core.Particle.ParticleEmitter.Texture">
            <summary>
                Textura utilizada
            </summary>
        </member>
        <member name="M:TGC.Core.Particle.ParticleEmitter.changeTexture(System.String)">
            <summary>
                Cambiar la textura de las particulas
            </summary>
        </member>
        <member name="M:TGC.Core.Particle.ParticleEmitter.dispose">
            <summary>
                Liberar recursos
            </summary>
        </member>
        <member name="M:TGC.Core.Particle.ParticleEmitter.render(System.Single)">
            <summary>
                Dibujar particulas.
                Emite particulas a medida que avanza el tiempo.
            </summary>
        </member>
        <member name="M:TGC.Core.Particle.ParticleEmitter.createParticle">
            <summary>
                Crear una nueva particula
            </summary>
        </member>
        <member name="M:TGC.Core.Particle.ParticleEmitter.updateExistingParticle(System.Single,TGC.Core.Particle.Particle)">
            <summary>
                Actualizar el estado de una particula existente
            </summary>
        </member>
        <member name="M:TGC.Core.Particle.ParticleEmitter.renderParticle(TGC.Core.Particle.Particle)">
            <summary>
                Dibujar particula
            </summary>
        </member>
        <member name="T:TGC.Core.Particle.PilaDeParticulas">
            <summary>
                Pila para almacenar particulas
            </summary>
        </member>
        <member name="T:TGC.Core.PortalRendering.TgcPortalRenderingCell">
            <summary>
                Celda de PortalRendering
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingCell.ConvexPolyhedron">
            <summary>
                Volúmen convexo de la celda
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingCell.Name">
            <summary>
                Nombre de la celda
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingCell.Meshes">
            <summary>
                Modelos dentro de la celda
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingCell.Connections">
            <summary>
                Conexiones con otras celdas, a través de portales
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingCell.Visited">
            <summary>
                Indica si la celda ya fue visitada por el algoritmo de visibilidad
            </summary>
        </member>
        <member name="T:TGC.Core.PortalRendering.TgcPortalRenderingCellData">
            <summary>
                Datos de una celda de PortalRendering
            </summary>
        </member>
        <member name="T:TGC.Core.PortalRendering.TgcPortalRenderingConnection">
            <summary>
                Conexión unidireccional entre una celda y otra, a travez de un Portal
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingConnection.Portal">
            <summary>
                Portal de la conexion
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingConnection.NextCell">
            <summary>
                Celda con la cual comunica
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingConnection.Polygon">
            <summary>
                Polígono plano que representa el portal.
                Los vértices están en clockwise-order según la celda de origen
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingConnection.Plane">
            <summary>
                Plano del portal, apuntando hacia la celda origen
            </summary>
        </member>
        <member name="T:TGC.Core.PortalRendering.TgcPortalRenderingData">
            <summary>
                Datos de una escena con PortalRendering
            </summary>
        </member>
        <member name="T:TGC.Core.PortalRendering.TgcPortalRenderingLoader">
            <summary>
                Loader de información de PortalRendering de una escena
            </summary>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingLoader.loadFromData(TGC.Core.SceneLoader.TgcScene,TGC.Core.PortalRendering.TgcPortalRenderingData)">
            <summary>
                Cargar información de PortalRendering
            </summary>
        </member>
        <member name="T:TGC.Core.PortalRendering.TgcPortalRenderingManager">
            <summary>
                Herramienta para optimizar la visibilidad de objetos mediante PortalRendering.
                Determina que objetos se ven y cuales no en base a celdas y portales.
                Esta herramienta implementa una estrategia de Portal Rendering muy básica.
                Aún posee muchos aspectos para pulir y optimizar.
            </summary>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.#ctor(TGC.Core.SceneLoader.TgcScene)">
            <summary>
                Crear TexturesManager
            </summary>
            <param name="scene">Escenario a administrar</param>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingManager.Cells">
            <summary>
                Celdas
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingManager.Portals">
            <summary>
                Portales
            </summary>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.updateVisibility(Microsoft.DirectX.Vector3,TGC.Core.BoundingVolumes.TgcFrustum)">
            <summary>
                Actualiza la visibilidad de todos los modelos de las celdas.
                Las modelos visibles se cargan como Enable = true, mientras que el
                resto se deshabilita.
            </summary>
            <param name="cameraPos">Posición de la cámara</param>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.render">
            <summary>
                Renderiza todos los meshes habilitados, y los vuelve a marcar como inhabilitados
                para el próximo cuadro.
                Debe ejecutarse luego de haber llamado a updateVisibility()
            </summary>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.traverseCellGraph(Microsoft.DirectX.Vector3,Microsoft.DirectX.Plane[],TGC.Core.PortalRendering.TgcPortalRenderingCell)">
            <summary>
                Recorrer el grafo de celdas y portales
            </summary>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.createFrustumPlanes(Microsoft.DirectX.Vector3,Microsoft.DirectX.Plane[],Microsoft.DirectX.Vector3[],Microsoft.DirectX.Plane)">
            <summary>
                Crear un nuevo Frustum acotado usando como base el portal recorado.
                La cantidad de planos del nuevo Frustum no tiene por qué ser 6.
                Depende de la forma que haya quedado en el portal recortado.
            </summary>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.doPortalClipping(Microsoft.DirectX.Plane[],TGC.Core.Geometry.TgcConvexPolygon)">
            <summary>
                Recorta el portal en base al frustum.
                Este método se realiza haciendo un clipping del Frustum contra la cara del portal.
                El recorte se hace en 3D.
                Existen técnicas más eficientes para realizar el clipping en 2D, utilizando la proyección del BoundingBox del
                portal.
                Ver Capítulo 13 - Portal Rendering, del libro Core Techniques and Algorithms in Game Programming, para optimizar la
                estrategia.
            </summary>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.findVisibleMeshes(TGC.Core.PortalRendering.TgcPortalRenderingCell,Microsoft.DirectX.Plane[])">
            <summary>
                Habilitar los modelos visibles de esta celda, según el Frustum restringido
            </summary>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.findCellFromPoint(Microsoft.DirectX.Vector3)">
            <summary>
                Busca y devuelve la celda que contenga al punto q.
                Devuelve null en caso de que ninguna celda lo contenga.
            </summary>
            <param name="q">Punto buscado</param>
            <returns>Celda que lo contiene o null</returns>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.createDebugPortals(System.Drawing.Color)">
            <summary>
                Crear meshes de debug para renderizar portales
            </summary>
            <param name="portalColor">Color de portales</param>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.renderPortals">
            <summary>
                Renderizar meshes de debug de Portales visitados
            </summary>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingManager.dispose">
            <summary>
                Libera todos los recursos
            </summary>
        </member>
        <member name="T:TGC.Core.PortalRendering.TgcPortalRenderingParser">
            <summary>
                Parser de la información de Portal Rendering exportada por el plugin
            </summary>
        </member>
        <member name="M:TGC.Core.PortalRendering.TgcPortalRenderingParser.parseFromXmlNode(System.Xml.XmlElement)">
            <summary>
                Parsea la información de PortalRendering
            </summary>
        </member>
        <member name="T:TGC.Core.PortalRendering.TgcPortalRenderingPortal">
            <summary>
                Portal de PortalRendering que comunica dos celdas
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingPortal.Name">
            <summary>
                Nombre del portal
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingPortal.BoundingBox">
            <summary>
                BoundingBox del Portal
            </summary>
        </member>
        <member name="P:TGC.Core.PortalRendering.TgcPortalRenderingPortal.Visited">
            <summary>
                Indica si la celda ya fue visitada por el algoritmo de visibilidad
            </summary>
        </member>
        <member name="T:TGC.Core.PortalRendering.TgcPortalRenderingPortalData">
            <summary>
                Datos de un Portal de PortalRendering
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.IRenderObject">
            <summary>
                Interfaz generica para renderizar objetos
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.IRenderObject.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.IRenderObject.render">
            <summary>
                Renderiza el objeto
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.IRenderObject.dispose">
            <summary>
                Libera los recursos del objeto
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.ITransformObject">
            <summary>
                Interfaz genérica para permitir que se le apliquen transformaciones a un objeto
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.ITransformObject.Transform">
            <summary>
                Matriz final que se utiliza para aplicar transformaciones al objeto.
                Si la propiedad AutoTransformEnable esta en True, la matriz se reconstruye en cada cuadro
                en base a los valores de: Position, Rotation, Scale.
                Si AutoTransformEnable está en False, se respeta el valor que el usuario haya cargado en la matriz.
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.ITransformObject.AutoTransformEnable">
            <summary>
                En True hace que la matriz de transformacion (Transform) del objeto se actualiza en
                cada cuadro en forma automática, según los valores de: Position, Rotation, Scale.
                En False se respeta lo que el usuario haya cargado a mano en la matriz.
                Por default está en True.
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.ITransformObject.Position">
            <summary>
                Posicion absoluta del objeto
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.ITransformObject.Rotation">
            <summary>
                Rotación absoluta del objeto
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.ITransformObject.Scale">
            <summary>
                Escalado absoluto del objeto
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.ITransformObject.move(Microsoft.DirectX.Vector3)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.ITransformObject.move(System.Single,System.Single,System.Single)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.ITransformObject.moveOrientedY(System.Single)">
            <summary>
                Mueve la malla en base a la orientacion actual de rotacion.
                Es necesario rotar la malla primero
            </summary>
            <param name="movement">Desplazamiento. Puede ser positivo (hacia adelante) o negativo (hacia atras)</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.ITransformObject.getPosition(Microsoft.DirectX.Vector3)">
            <summary>
                Obtiene la posicion absoluta de la malla, recibiendo un vector ya creado para
                almacenar el resultado
            </summary>
            <param name="pos">Vector ya creado en el que se carga el resultado</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.ITransformObject.rotateX(System.Single)">
            <summary>
                Rota la malla respecto del eje X
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.ITransformObject.rotateY(System.Single)">
            <summary>
                Rota la malla respecto del eje Y
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.ITransformObject.rotateZ(System.Single)">
            <summary>
                Rota la malla respecto del eje Z
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcMesh">
            <summary>
                Representa una malla estática.
                Puede moverse y rotarse pero no tiene animación.
                La malla puede tener colores por vértice, texturas y lightmaps.
                Puede crearse como una malla nueva o como una instancia de otra existente y reutilizar así su geometría.
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcMesh.MeshRenderType">
            <summary>
                Tipos de de renderizado de mallas
            </summary>
        </member>
        <member name="F:TGC.Core.SceneLoader.TgcMesh.MeshRenderType.VERTEX_COLOR">
            <summary>
                Solo colores por vertice
            </summary>
        </member>
        <member name="F:TGC.Core.SceneLoader.TgcMesh.MeshRenderType.DIFFUSE_MAP">
            <summary>
                Solo un canal de textura en DiffuseMap
            </summary>
        </member>
        <member name="F:TGC.Core.SceneLoader.TgcMesh.MeshRenderType.DIFFUSE_MAP_AND_LIGHTMAP">
            <summary>
                Un canal de textura en DiffuseMap y otro para Lightmap,
                utilizando Multitexture
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.#ctor">
            <summary>
                Constructor vacio, para facilitar la herencia de esta clase.
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.#ctor(Microsoft.DirectX.Direct3D.Mesh,System.String,TGC.Core.SceneLoader.TgcMesh.MeshRenderType)">
            <summary>
                Crea una nueva malla.
            </summary>
            <param name="mesh">Mesh de DirectX</param>
            <param name="name">Nombre de la malla</param>
            <param name="renderType">Formato de renderizado de la malla</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.#ctor(System.String,TGC.Core.SceneLoader.TgcMesh,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una nueva malla que es una instancia de otra malla original.
                Reutiliza toda la geometría de la malla original sin duplicarla.
            </summary>
            <param name="name">Nombre de la malla</param>
            <param name="parentInstance">Malla original desde la cual basarse</param>
            <param name="translation">Traslación respecto de la malla original</param>
            <param name="rotation">Rotación respecto de la malla original</param>
            <param name="scale">Escala respecto de la malla original</param>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.D3dMesh">
            <summary>
                Mesh interna de DirectX
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.Name">
            <summary>
                Nombre de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.Layer">
            <summary>
                Layer al que pertenece la malla.
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.UserProperties">
            <summary>
                User properties de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.Materials">
            <summary>
                Array de Materials
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.DiffuseMaps">
            <summary>
                Array de texturas para DiffuseMap
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.LightMap">
            <summary>
                Textura de LightMap
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.Enabled">
            <summary>
                Indica si la malla esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.BoundingBox">
            <summary>
                BoundingBox del Mesh
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.RenderType">
            <summary>
                Tipo de formato de Render de esta malla
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.VertexDeclaration">
            <summary>
                VertexDeclaration del Flexible Vertex Format (FVF) usado por la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.AutoUpdateBoundingBox">
            <summary>
                Indica si se actualiza automaticamente el BoundingBox con cada movimiento de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.ParentInstance">
            <summary>
                Original desde el cual esta malla fue clonada.
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.MeshInstances">
            <summary>
                Lista de mallas que fueron clonadas a partir de este original
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.NumberTriangles">
            <summary>
                Cantidad de triángulos de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.NumberVertices">
            <summary>
                Cantidad de vértices de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.render">
            <summary>
                Renderiza la malla, si esta habilitada
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.dispose">
            <summary>
                Libera los recursos de la malla.
                Si la malla es una instancia se deshabilita pero no se liberan recursos.
                Si la malla es el original y tiene varias instancias adjuntadas, se hace dispose() también de las instancias.
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.Transform">
            <summary>
                Matriz final que se utiliza para aplicar transformaciones a la malla.
                Si la propiedad AutoTransformEnable esta en True, la matriz se reconstruye en cada cuadro
                en base a los valores de: Position, Rotation, Scale.
                Si AutoTransformEnable está en False, se respeta el valor que el usuario haya cargado en la matriz.
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.AutoTransformEnable">
            <summary>
                En True hace que la matriz de transformacion (Transform) de la malla se actualiza en
                cada cuadro en forma automática, según los valores de: Position, Rotation, Scale.
                En False se respeta lo que el usuario haya cargado a mano en la matriz.
                Por default está en True.
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.Position">
            <summary>
                Posicion absoluta de la Malla
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.Rotation">
            <summary>
                Rotación absoluta de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcMesh.Scale">
            <summary>
                Escalado absoluto de la malla;
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.move(Microsoft.DirectX.Vector3)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.move(System.Single,System.Single,System.Single)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.moveOrientedY(System.Single)">
            <summary>
                Mueve la malla en base a la orientacion actual de rotacion.
                Es necesario rotar la malla primero
            </summary>
            <param name="movement">Desplazamiento. Puede ser positivo (hacia adelante) o negativo (hacia atras)</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.getPosition(Microsoft.DirectX.Vector3)">
            <summary>
                Obtiene la posicion absoluta de la malla, recibiendo un vector ya creado para
                almacenar el resultado
            </summary>
            <param name="pos">Vector ya creado en el que se carga el resultado</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.rotateX(System.Single)">
            <summary>
                Rota la malla respecto del eje X
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.rotateY(System.Single)">
            <summary>
                Rota la malla respecto del eje Y
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.rotateZ(System.Single)">
            <summary>
                Rota la malla respecto del eje Z
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.initData(Microsoft.DirectX.Direct3D.Mesh,System.String,TGC.Core.SceneLoader.TgcMesh.MeshRenderType)">
            <summary>
                Cargar datos iniciales
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.setShaderMatrix">
            <summary>
                Cargar todas la matrices que necesita el shader
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.UpdateMeshTransform">
            <summary>
                Actualiza la matriz de transformacion con los datos internos del mesh (scale. rotation, traslation) para casos complejos es mejor no utilizar este metodo.
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.activateAlphaBlend">
            <summary>
                Activar AlphaBlending, si corresponde
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.resetAlphaBlend">
            <summary>
                Desactivar AlphaBlending
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.getVertexPositions">
            <summary>
                Devuelve un array con todas las posiciones de los vértices de la malla
            </summary>
            <returns>Array creado</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.getTextureCoordinates">
            <summary>
                Devuelve un array con todas las coordenadas de textura de la malla
                Solo puede hacerse para meshes del tipo DIFFUSE_MAP y DIFFUSE_MAP_AND_LIGHTMAP.
            </summary>
            <returns>Array creado</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.createBoundingBox">
            <summary>
                Calcula el BoundingBox de la malla, en base a todos sus vertices.
                Llamar a este metodo cuando ha cambiado la estructura interna de la malla.
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.updateBoundingBox">
            <summary>
                Actualiza el BoundingBox de la malla, en base a su posicion actual.
                Solo contempla traslacion y escalado
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.setColor(System.Drawing.Color)">
            <summary>
                Cambia el color de todos los vértices de la malla.
                Esta operacion tiene que hacer un lock del VertexBuffer y es poco performante.
            </summary>
            <param name="color">Color nuevo</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.changeDiffuseMaps(TGC.Core.Textures.TgcTexture[])">
            <summary>
                Permite cambiar las texturas de DiffuseMap de esta malla
            </summary>
            <param name="newDiffuseMaps">Array de nuevas texturas. Tiene que tener la misma cantidad que el original</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.addDiffuseMap(TGC.Core.Textures.TgcTexture)">
            <summary>
                Agregar una nueva textura a la lista de texturas que tiene el mesh.
                Esta nueva textura no va a ser utilizada por ningún triángulo si no se
                adapta correctamente el attributeBuffer.
                No se controla si esa textura ya esta repetida en el mesh.
            </summary>
            <param name="newDiffuseMap">Nueva textura</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.deleteDiffuseMap(System.Int32,System.Int32)">
            <summary>
                Eliminar un slot de textura del mesh.
                Se modifica el attributeBuffer para que todos los triangulos que
                apuntaban a esta textura ahora apunten a replacementSlot
            </summary>
            <param name="diffuseMapSlot">Slot de textura a eliminar</param>
            <param name="replacementSlot">Nuevo slot al que apuntan los triangulos que usaban el anterior</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.createMeshInstance(System.String,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una nueva malla que es una instancia de esta malla original
                Reutiliza toda la geometría de la malla original sin duplicarla.
                Solo se puede crear instancias a partir de originales.
            </summary>
            <param name="name">Nombre de la malla</param>
            <param name="translation">Traslación respecto de la malla original</param>
            <param name="rotation">Rotación respecto de la malla original</param>
            <param name="scale">Escala respecto de la malla original</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.createMeshInstance(System.String)">
            <summary>
                Crea una nueva malla que es una instancia de esta malla original
                Reutiliza toda la geometría de la malla original sin duplicarla.
                Solo se puede crear instancias a partir de originales.
            </summary>
            <param name="name">Nombre de la malla</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.clone(System.String)">
            <summary>
                Crear un nuevo mesh igual
            </summary>
            <param name="cloneName">Nombre del mesh clonado</param>
            <returns>Mesh clonado</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.changeD3dMesh(Microsoft.DirectX.Direct3D.Mesh)">
            <summary>
                Cambiar el mesh interno de DirectX por uno nuevo.
                Se asume que el nuevo mesh es del mismo RenderType que el anterior.
            </summary>
            <param name="newD3dMesh">Nuevo mesh</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcMesh.lockVertexBuffer(Microsoft.DirectX.Direct3D.LockFlags)">
            <summary>
                Acceder al VertexBuffer del mesh.
                Una vez que se termina de trabajar con el buffer se debe invocar siempre a unlock.
            </summary>
            <param name="lockFlags">Flags de lectura del buffer</param>
            <returns>array de elementos</returns>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcScene">
            <summary>
                Escena compuesta por un conjunto de Meshes estáticos
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcScene.#ctor(System.String,System.String)">
            <summary>
                Crea una nueva escena
            </summary>
            <param name="sceneName">Nombre de la escena</param>
            <param name="filePath">Path del archivo XML</param>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcScene.SceneName">
            <summary>
                Nombre de la escena
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcScene.FilePath">
            <summary>
                Path del archivo XML de la escena
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcScene.Meshes">
            <summary>
                Mallas cargadas en la escena
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcScene.BoundingBox">
            <summary>
                BoundingBox de toda la escena, englobando todos los modelos.
                No se actualiza con los movimientos particulares de cada modelo.
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcScene.PortalRendering">
            <summary>
                Herramienta de PortalRendering.
                Puede estar en null si no hay información cargada para esto.
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcScene.setMeshesEnabled(System.Boolean)">
            <summary>
                Habilita o deshabilita todas las mallas
            </summary>
            <param name="flag"></param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcScene.renderAll">
            <summary>
                Renderiza todas las mallas que se encuentran habilitadas
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcScene.renderAll(System.Boolean)">
            <summary>
                Renderiza todas las mallas que se encuentran habilitadas, indicando
                si se debe mostrar el BoundingBox de las mismas.
            </summary>
            <param name="showBoundingBox">True para renderizar el BoundingBox de cada malla</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcScene.disposeAll">
            <summary>
                Libera los recursos de todas las mallas
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcScene.separeteMeshList(System.String[],System.Collections.Generic.List{TGC.Core.SceneLoader.TgcMesh}@,System.Collections.Generic.List{TGC.Core.SceneLoader.TgcMesh}@)">
            <summary>
                Devuelve dos listas de meshes utilizando el criterio establecido.
                Todos los meshes cuyo nombre está en el array list1Criteria se cargan en la list1.
                El resto se cargan en la list2.
            </summary>
            <param name="list1Criteria">Nombre de meshes a filtrar</param>
            <param name="list1">Lista con los meshes que cumplen con list1Criteria</param>
            <param name="list2">Lista con el resto de los meshes</param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcScene.getMeshByName(System.String)">
            <summary>
                Devuelve el mesh con el nombre indicado
            </summary>
            <param name="meshName">Nombre del mesh buscado</param>
            <returns>Mesh encontrado o null si no encontró ninguno</returns>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneExporter">
            <summary>
                Herramienta para exportar un conjunto de modelos TgcMesh a un archivo XML de formato TGC.
                Es similar a lo que hace el plugin de 3Ds MAX TgcSceneExporter.ms, pero hecho desde C#
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.exportSceneToXml(TGC.Core.SceneLoader.TgcScene,System.String)">
            <summary>
                Graba una escena entera del tipo TgcScene a un archivo XML de tipo "-TgcScene.xml", que luego
                puede ser cargado con el TgcSceneLoader
            </summary>
            <param name="scene">Escena a exportar</param>
            <param name="saveFolderPath">Carpeta en la que se quiera guardar el XML</param>
            <returns>Resultado de exportacion</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.exportAndAppendSceneToXml(TGC.Core.SceneLoader.TgcScene,System.String)">
            <summary>
                Graba una escena entera del tipo TgcScene a un archivo XML de tipo "-TgcScene.xml", que luego
                puede ser cargado con el TgcSceneLoader
                Antes de generar el XML, unifica todas las mallas en una sola, adaptando sus coordendas de textura y Materials.
                Actualmente no se puede hacer con Mallas que tengan LightMaps.
            </summary>
            <param name="scene">Escena a exportar</param>
            <param name="saveFolderPath">Carpeta en la que se quiera guardar el XML</param>
            <returns>Resultado de exportacion</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.createSceneBoundingBox(TGC.Core.SceneLoader.TgcSceneExporter.MeshExport[])">
            <summary>
                Crear BoundingBox para escena
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneExporter.ExportResult">
            <summary>
                Resultado de exportacion
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.exportSceneData(TGC.Core.SceneLoader.TgcScene)">
            <summary>
                Exporta los datos de todas los TgcMesh de una escena. Los exporta a un formato de objetos plano
            </summary>
            <param name="scene">Escena a exportar</param>
            <returns>Datos de la mallas en objetos</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.exportAndAppendSceneData(TGC.Core.SceneLoader.TgcScene)">
            <summary>
                Exporta los datos de todas los TgcMesh de una escena. Los exporta a un formato de objetos plano.
                Unifica todas las Mallas de la escena en una sola, adaptando sus coordendas de textura y Materials.
                Actualmente no se puede hacer con Mallas que tengan LightMaps.
            </summary>
            <param name="scene">Escena a unificar y exportar</param>
            <returns>Datos de la escena unificada y exportada</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.exportMeshData(TGC.Core.SceneLoader.TgcMesh,System.Collections.Generic.List{TGC.Core.SceneLoader.TgcMesh})">
            <summary>
                Toma los datos de un TgcMesh y los exporta a un formato de objetos plano
            </summary>
            <param name="tgcMesh">Malla a exportar</param>
            <returns>Datos de la malla en objetos</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.exportMeshVertexColor(TGC.Core.SceneLoader.TgcMesh,TGC.Core.SceneLoader.TgcSceneExporter.MeshExport,TGC.Core.SceneLoader.TgcMeshData)">
            <summary>
                Exportar datos de Mesh de tipo TgcMesh.MeshRenderType.VERTEX_COLOR
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.exportMeshDiffuseMap(TGC.Core.SceneLoader.TgcMesh,TGC.Core.SceneLoader.TgcSceneExporter.MeshExport,TGC.Core.SceneLoader.TgcMeshData)">
            <summary>
                Exportar datos de Malla del tipo TgcMesh.MeshRenderType.DIFFUSE_MAP
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.exportMeshDiffuseMapAndLightmap(TGC.Core.SceneLoader.TgcMesh,TGC.Core.SceneLoader.TgcSceneExporter.MeshExport,TGC.Core.SceneLoader.TgcMeshData)">
            <summary>
                Exportar datos de Mesh de formato TgcMesh.MeshRenderType.DIFFUSE_MAP_AND_LIGHTMAP
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.exportMaterialData(TGC.Core.SceneLoader.TgcMesh,TGC.Core.SceneLoader.TgcSceneExporter.MeshExport,TGC.Core.SceneLoader.TgcMeshData)">
            <summary>
                Exportar datos de Material
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.addVertex(System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{Microsoft.DirectX.Vector3},Microsoft.DirectX.Vector3)">
            <summary>
                Agregar un vertice sin repetir
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.addTextureCoordinates(System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{Microsoft.DirectX.Vector2},Microsoft.DirectX.Vector2)">
            <summary>
                Agregar una coordenada de textura sin repetir
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.addNormal(System.Collections.Generic.List{Microsoft.DirectX.Vector3},System.Int32,Microsoft.DirectX.Vector3)">
            <summary>
                Agregar una normal en base a los indices de vertices
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.addColor(System.Collections.Generic.List{System.Int32},System.Collections.Generic.List{System.Int32},System.Int32)">
            <summary>
                Agregar un color sin repetir
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.equalsVector3(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Compara que dos Vector3 sean iguales, o casi
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.equalsVector2(Microsoft.DirectX.Vector2,Microsoft.DirectX.Vector2)">
            <summary>
                Compara que dos Vector2 sean iguales, o casi
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.equalsFloat(System.Single,System.Single)">
            <summary>
                Compara que dos floats sean iguales, o casi
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneExporter.MeshExport">
            <summary>
                Datos de un TgcMesh exportado
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.appendAllMeshes(System.String,TGC.Core.SceneLoader.TgcSceneExporter.MeshExport[])">
            <summary>
                Unifica N Mallas en una sola, adaptando sus coordendas de textura y Materials.
                Actualmente no se puede hacer con Mallas que tengan LightMaps.
            </summary>
            <param name="meshName">Nuevo nombre de malla</param>
            <param name="meshesExport">Array de mallas a unificar</param>
            <returns>Datos de nueva malla unificada</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.appendMeshes(System.String,TGC.Core.SceneLoader.TgcSceneExporter.MeshExport,TGC.Core.SceneLoader.TgcSceneExporter.MeshExport)">
            <summary>
                Unifica dos Mallas en una, adaptando sus coordendas de textura y Materials.
                Actualmente no se puede hacer con Mallas que tengan LightMaps.
            </summary>
            <param name="meshName">Nuevo nombre de malla</param>
            <param name="mExp1">Datos de malla 1</param>
            <param name="mExp2">Datos de malla 2</param>
            <returns>Datos de nueva malla unificada</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.mergeMeshes(System.Collections.Generic.List{TGC.Core.SceneLoader.TgcMesh})">
            <summary>
                Unifica todos los meshes en uno solo.
                Crea un nuevo mesh que tiene un merge de todos los demas.
                Toma el nombre, layer, userProperties, etc del primer mesh.
                Todos los meshes tienen que ser del mismo RenderType.
                No se puede hacer merge de meshes con Lightmap.
                No se hace dispose de los meshes originales
            </summary>
            <param name="meshes"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.mergeTwoMeshes(TGC.Core.SceneLoader.TgcMesh,TGC.Core.SceneLoader.TgcMesh)">
            <summary>
                Une dos meshes en uno solo.
                Crea un nuevo mesh con un merge de los dos. Toma el nombre, layer, userProperties, etc del primer mesh.
                No se hace dispose de los dos meshes originales.
                Ambos mesh tienen que ser del mismo RenderType.
                No se puede hacer merge de un mesh con Lightmap
            </summary>
            <param name="mesh1">Primer mesh</param>
            <param name="mesh2">Segundo mesh</param>
            <returns>Nueve mesh con el merge de los dos</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.saveSceneToXml(System.String,TGC.Core.BoundingVolumes.TgcBoundingAxisAlignBox,TGC.Core.SceneLoader.TgcSceneExporter.MeshExport[],System.String)">
            <summary>
                Graba una escena a XML, en base a información de varios TgcMesh.
                También crea una carpeta Textures relativa al XML y copia ahí todas las texturas utilizadas por las Mallas.
                Lo mismo para LightMaps.
            </summary>
            <param name="sceneName">Nombre de la escena</param>
            <param name="sceneBoundingBox">BoundingBox de toda la escena</param>
            <param name="meshesExport">Array de datos de Mallas que se quieren exportar</param>
            <param name="saveFolderPath">Carpeta en la que se quiera guardar el XML</param>
            <returns>Resultado de exportacion</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.copyFile(System.String,System.String)">
            <summary>
                Copiar archivo
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.searchSameMaterial(TGC.Core.SceneLoader.TgcSceneExporter.MeshExport,System.Collections.Generic.List{TGC.Core.SceneLoader.TgcSceneExporter.MeshExport})">
            <summary>
                Busca si existe un Material similar a este.
                Devuelve el indice encontrado o -1
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.equalsMaterial(TGC.Core.SceneLoader.TgcMaterialData,TGC.Core.SceneLoader.TgcMaterialData)">
            <summary>
                Indica si dos TgcMaterialData son iguales, en base a si utilizan la misma textura
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneExporter.createMaterialXmlNode(System.Xml.XmlDocument,TGC.Core.SceneLoader.TgcMaterialData,System.String)">
            <summary>
                Crear nodo XML de Material
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneLoader">
            <summary>
                Herramienta para cargar un archivo de escena XML con formato de TGC (tgcScene)
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.#ctor">
            <summary>
                Crear un nuevo Loader
            </summary>
        </member>
        <member name="P:TGC.Core.SceneLoader.TgcSceneLoader.MeshFactory">
            <summary>
                Factory utilizado para crear una instancia de TgcMesh.
                Por default se utiliza la clase DefaultMeshFactory.
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.loadSceneFromFile(System.String,System.String)">
            <summary>
                Carga una escena a partir de un archivo
            </summary>
            <param name="filePath">Ubicacion del archivo XML</param>
            <param name="mediaPath">Path a partir del cual hay que buscar los recursos de escena (Texturas, LightMaps, etc.)</param>
            <returns>Escena cargada</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.loadSceneFromFile(System.String)">
            <summary>
                Carga una escena a partir de un archivo.
                Como carpeta de Media utiliza la misma carpeta en la que se encuentra el archivo XML de la malla
            </summary>
            <param name="filePath">Ubicacion del archivo XML</param>
            <returns>Escena cargada</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.loadSceneFromZipFile(System.String,System.String,System.String)">
            <summary>
                Carga una escena a partir de un archivo en formato .ZIP.
                Se asume que dentro del ZIP se encuentra el archivo XML de la escena y todas las texturas necesarias.
            </summary>
            <param name="sceneFileName">Nombre del archivo XML que tiene la información de la escena</param>
            <param name="zipFilePath">Path del archivo ZIP que contiene la escena.</param>
            <param name="extractDir">Path del directorio en donde se va a extraer el ZIP</param>
            <returns>Escena cargada</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.loadSceneFromString(System.String,System.String)">
            <summary>
                Carga la escena a partir del string del XML
            </summary>
            <param name="xmlString">contenido del XML</param>
            <param name="mediaPath">Path a partir del cual hay que buscar los recursos de escena (Texturas, LightMaps, etc.)</param>
            <returns>Escena cargada</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.loadScene(TGC.Core.SceneLoader.TgcSceneData,System.String)">
            <summary>
                Carga la escena a partir de un objeto TgcSceneData ya parseado
            </summary>
            <param name="sceneData">Objeto con datos de la escena ya parseados</param>
            <param name="mediaPath">Path a partir del cual hay que buscar los recursos de escena (Texturas, LightMaps, etc.)</param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.crearMeshDiffuseMapLightmap(TGC.Core.SceneLoader.TgcSceneData,System.String,TGC.Core.SceneLoader.TgcSceneLoader.TgcSceneLoaderMaterialAux[],TGC.Core.SceneLoader.TgcMeshData)">
            <summary>
                Crea un mesh con uno o varios DiffuseMap y un Lightmap
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.crearMeshDiffuseMap(TGC.Core.SceneLoader.TgcSceneLoader.TgcSceneLoaderMaterialAux[],TGC.Core.SceneLoader.TgcMeshData)">
            <summary>
                Crea un mesh con uno o varios DiffuseMap
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.crearMeshSoloColor(TGC.Core.SceneLoader.TgcMeshData)">
            <summary>
                Crea un mesh sin texturas, solo con VertexColors
            </summary>
            <param name="meshData"></param>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.crearMeshInstance(TGC.Core.SceneLoader.TgcMeshData,System.Collections.Generic.List{TGC.Core.SceneLoader.TgcMesh})">
            <summary>
                Crear una malla instancia de una original
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.quaternionToEuler(Microsoft.DirectX.Quaternion)">
            <summary>
                Convierte un Quaternion a rotación de Euler
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.createTextureAndMaterial(TGC.Core.SceneLoader.TgcMaterialData,System.String)">
            <summary>
                Crea Material y Textura
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneLoader.TgcSceneLoaderMaterialAux">
            <summary>
                Estructura auxiliar para cargar SubMaterials y Texturas
            </summary>
        </member>
        <member name="F:TGC.Core.SceneLoader.TgcSceneLoader.VertexColorVertexElements">
            <summary>
                FVF para formato de malla VERTEX_COLOR
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneLoader.VertexColorVertex">
            <summary>
                Estructura de Vertice para formato de malla VERTEX_COLOR
            </summary>
        </member>
        <member name="F:TGC.Core.SceneLoader.TgcSceneLoader.DiffuseMapVertexElements">
            <summary>
                FVF para formato de malla DIFFUSE_MAP
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneLoader.DiffuseMapVertex">
            <summary>
                Estructura de Vertice para formato de malla DIFFUSE_MAP
            </summary>
        </member>
        <member name="F:TGC.Core.SceneLoader.TgcSceneLoader.DiffuseMapAndLightmapVertexElements">
            <summary>
                FVF para formato de malla DIFFUSE_MAP_AND_LIGHTMAP
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneLoader.DiffuseMapAndLightmapVertex">
            <summary>
                Estructura de Vertice para formato de malla DIFFUSE_MAP_AND_LIGHTMAP
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneLoader.IMeshFactory">
            <summary>
                Factory para permitir crear una instancia especifica de la clase TgcMesh
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.IMeshFactory.createNewMesh(Microsoft.DirectX.Direct3D.Mesh,System.String,TGC.Core.SceneLoader.TgcMesh.MeshRenderType)">
            <summary>
                Crear una nueva instancia de la clase TgcMesh o derivados
            </summary>
            <param name="d3dMesh">Mesh de Direct3D</param>
            <param name="meshName">Nombre de la malla</param>
            <param name="renderType">Tipo de renderizado de la malla</param>
            <param name="meshData">Datos de la malla</param>
            <returns>Instancia de TgcMesh creada</returns>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneLoader.IMeshFactory.createNewMeshInstance(System.String,TGC.Core.SceneLoader.TgcMesh,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crear una nueva malla que es una instancia de otra malla original.
                Crear una instancia de la clase TgcMesh o derivados
            </summary>
            <param name="name">Nombre de la malla</param>
            <param name="parentInstance">Malla original desde la cual basarse</param>
            <param name="translation">Traslación respecto de la malla original</param>
            <param name="rotation">Rotación respecto de la malla original</param>
            <param name="scale">Escala respecto de la malla original</param>
            <returns>Instancia de TgcMesh creada</returns>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneLoader.DefaultMeshFactory">
            <summary>
                Factory default que crea una instancia de la clase TgcMesh
            </summary>
        </member>
        <member name="T:TGC.Core.SceneLoader.TgcSceneParser">
            <summary>
                Parser de XML de escena creado con plugin TgcSceneExporter.ms de 3DsMax
            </summary>
        </member>
        <member name="M:TGC.Core.SceneLoader.TgcSceneParser.parseSceneFromString(System.String)">
            <summary>
                Levanta la informacion del XML
            </summary>
            <param name="xmlString">contenido del XML</param>
            <returns></returns>
        </member>
        <member name="T:TGC.Core.Shaders.TgcPostProcessingUtils">
            <summary>
                Utilidades generales para shaders de post-procesado
            </summary>
        </member>
        <member name="M:TGC.Core.Shaders.TgcPostProcessingUtils.computeGaussianBlurSampleOffsets15(System.Single,System.Single,System.Single,System.Boolean,Microsoft.DirectX.Vector2[]@,System.Single[]@)">
            <summary>
                Calcular 15 offsets y weights para usar en un shader de Gaussian Blur de doble pasada (horizontal y vertical)
            </summary>
            <param name="textureSize">Ancho o alto de la textura, segun si es para horizontal o vertical</param>
            <param name="deviation">desviacion standard para distribucion de Gauss</param>
            <param name="multiplier">escala del weight de Gauss</param>
            <param name="horizontal">
                En true devuelve los valores de texCoordOffsets para hacer una pasada de shader horizontal,
                sino devuelve para una pasada verticual
            </param>
            <param name="texCoordOffsets">offsets generados para hacer sampling en el shader</param>
            <param name="colorWeights">weights generados para multiplicar los valores de los samplers en el shader</param>
        </member>
        <member name="M:TGC.Core.Shaders.TgcPostProcessingUtils.computeDownScaleOffsets4x4(System.Int32,System.Int32)">
            <summary>
                Calcular 16 offsets para hacer un down-sampling de 4x4
            </summary>
            <param name="textureWidth">Ancho de la textura original</param>
            <param name="textureHeight">Alto de la textura original</param>
            <returns>Offsets calculados</returns>
        </member>
        <member name="T:TGC.Core.Shaders.TgcScreenQuad">
            <summary>
                Utilidad para crear y renderizar un FullScreen Quad, útil para efectos de post-procesado
            </summary>
        </member>
        <member name="M:TGC.Core.Shaders.TgcScreenQuad.#ctor">
            <summary>
                Crear quad
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcScreenQuad.ScreenQuadVB">
            <summary>
                VertexBuffer del quad
            </summary>
        </member>
        <member name="M:TGC.Core.Shaders.TgcScreenQuad.render(Microsoft.DirectX.Direct3D.Effect)">
            <summary>
                Render de quad con shader.
                Setear previamente todos los parámetros de shader y technique correspondiente.
                Limpiar la pantalla segun sea necesario
            </summary>
        </member>
        <member name="M:TGC.Core.Shaders.TgcScreenQuad.dispose">
            <summary>
                Liberar recursos
            </summary>
        </member>
        <member name="T:TGC.Core.Shaders.TgcShaders">
            <summary>
                Utilidad para manejo de shaders
            </summary>
        </member>
        <member name="F:TGC.Core.Shaders.TgcShaders.T_POSITION_COLORED_TEXTURED">
            <summary>
                Technique de Varios para PositionColoredTextured
            </summary>
        </member>
        <member name="F:TGC.Core.Shaders.TgcShaders.T_POSITION_TEXTURED">
            <summary>
                Technique de Varios para PositionTextured
            </summary>
        </member>
        <member name="F:TGC.Core.Shaders.TgcShaders.T_POSITION_COLORED">
            <summary>
                Technique de Varios para PositionColored
            </summary>
        </member>
        <member name="F:TGC.Core.Shaders.TgcShaders.T_POSITION_COLORED_ALPHA">
            <summary>
                Technique de Varios para PositionColoredAlpha
            </summary>
        </member>
        <member name="F:TGC.Core.Shaders.TgcShaders.PositionColoredTextured_VertexElements">
            <summary>
                FVF para formato de vertice PositionColoredTextured
            </summary>
        </member>
        <member name="F:TGC.Core.Shaders.TgcShaders.PositionTextured_VertexElements">
            <summary>
                FVF para formato de vertice PositionTextured
            </summary>
        </member>
        <member name="F:TGC.Core.Shaders.TgcShaders.PositionColored_VertexElements">
            <summary>
                FVF para formato de vertice PositionColored
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.Instance">
            <summary>
                Permite acceder a una instancia de la clase TgcShaders desde cualquier parte del codigo.
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.TgcMeshShader">
            <summary>
                Shader generico para TgcMesh
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.TgcMeshPhongShader">
            <summary>
                Shader para TgcMesh con iluminacion dinamica con PhongShading
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.TgcMeshPointLightShader">
            <summary>
                Shader para TgcMesh con iluminacion dinamica por PointLight
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.TgcMeshSpotLightShader">
            <summary>
                Shader para TgcMesh con iluminacion dinamica por SpotLight
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.TgcSkeletalMeshShader">
            <summary>
                Shader generico para TgcSkeletalMesh
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.TgcSkeletalMeshPointLightShader">
            <summary>
                Shader para TgcSkeletalMesh con iluminacion dinamica por PointLight
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.TgcKeyFrameMeshShader">
            <summary>
                Shader generico para TgcKeyFrameMesh
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.VariosShader">
            <summary>
                Shader de cosas varias
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.VdecPositionColoredTextured">
            <summary>
                VertexDeclaration para formato PositionColoredTextured
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.VdecPositionTextured">
            <summary>
                VertexDeclaration para formato PositionTextured
            </summary>
        </member>
        <member name="P:TGC.Core.Shaders.TgcShaders.VdecPositionColored">
            <summary>
                VertexDeclaration para formato PositionColored
            </summary>
        </member>
        <member name="M:TGC.Core.Shaders.TgcShaders.loadCommonShaders(System.String)">
            <summary>
                Iniciar shaders comunes
            </summary>
        </member>
        <member name="M:TGC.Core.Shaders.TgcShaders.loadEffect(System.String)">
            <summary>
                Cargar archivo .fx de Shaders
            </summary>
            <param name="path">Path del archivo .fx</param>
            <returns>Effect cargado</returns>
        </member>
        <member name="M:TGC.Core.Shaders.TgcShaders.getTgcMeshTechnique(TGC.Core.SceneLoader.TgcMesh.MeshRenderType)">
            <summary>
                Obtener technique default para un TgcMesh según su MeshRenderType
            </summary>
            <param name="renderType">MeshRenderType</param>
            <returns>Nombre del Technique que le corresponde</returns>
        </member>
        <member name="M:TGC.Core.Shaders.TgcShaders.getTgcSkeletalMeshTechnique(TGC.Core.SkeletalAnimation.TgcSkeletalMesh.MeshRenderType)">
            <summary>
                Obtener technique default para un TgcSkeletalMesh según su MeshRenderType
            </summary>
            <param name="renderType">MeshRenderType</param>
            <returns>Nombre del Technique que le corresponde</returns>
        </member>
        <member name="M:TGC.Core.Shaders.TgcShaders.getTgcKeyFrameMeshTechnique(TGC.Core.KeyFrameLoader.TgcKeyFrameMesh.MeshRenderType)">
            <summary>
                Obtener technique default para un TgcKeyFrameMesh según su MeshRenderType
            </summary>
            <param name="renderType">MeshRenderType</param>
            <returns>Nombre del Technique que le corresponde</returns>
        </member>
        <member name="M:TGC.Core.Shaders.TgcShaders.setShaderMatrix(Microsoft.DirectX.Direct3D.Effect,Microsoft.DirectX.Matrix)">
            <summary>
                Cargar todas la matrices generales que necesita el shader
            </summary>
        </member>
        <member name="M:TGC.Core.Shaders.TgcShaders.setShaderMatrixIdentity(Microsoft.DirectX.Direct3D.Effect)">
            <summary>
                Cargar todas la matrices generales que necesita el shader, tomando
                como primicia que la matriz de world es la identidad.
                Simplica los calculos respecto a setShaderMatrix()
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalAnimation">
            <summary>
                Animacion para una malla con animacion esqueletica
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalAnimation.Name">
            <summary>
                Nombre de la animacion
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalAnimation.FrameRate">
            <summary>
                Velocidad de refresco de la animacion
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalAnimation.FramesCount">
            <summary>
                Total de cuadros que tiene la animacion
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalAnimation.BoneFrames">
            <summary>
                Frames de animacion por cada uno de los huesos.
                El array se encuentra en el mismo orden que la jerarquia de huesos del esquelto.
                Están todos los huesos, aunque no tengan ningún KeyFrame.
                Si no tienen ningun frame tienen la lista en null
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalAnimation.BoundingBox">
            <summary>
                BoundingBox para esta animacion particular
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalAnimation.hasFrames(System.Int32)">
            <summary>
                Indica si el hueso tiene algun KeyFrame
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalAnimationBoneData">
            <summary>
                Información de animación de un hueso para una animación particular
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalAnimationBoneFrameData">
            <summary>
                KeyFrame de animación de un hueso, para una animación particular
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalAnimationData">
            <summary>
                Información de animiación de un esqueleto
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalAnimationFrame">
            <summary>
                Key frame de animacion para un hueso particular
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalAnimationFrame.Frame">
            <summary>
                Numero de frame en el cual transcurre esta rotacion y traslacion.
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalAnimationFrame.Position">
            <summary>
                Posicion del hueso para este frame
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalAnimationFrame.Rotation">
            <summary>
                Rotacion del hueso para este frame en Quaternion
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalBone">
            <summary>
                Hueso del esqueleto
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBone.StartPosition">
            <summary>
                Posicion inicial del hueso
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBone.StartRotation">
            <summary>
                Rotacion inicial del hueso
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBone.MatLocal">
            <summary>
                Matriz local de transformacion
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBone.MatFinal">
            <summary>
                Matriz final de transformacion
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBone.MatInversePose">
            <summary>
                Matriz de transformacion inversa de la posicion inicial del hueso, para la animacion actual
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBone.Index">
            <summary>
                Posición del hueso dentro del array de huesos de todo el esqueleto
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBone.Name">
            <summary>
                Nombre del hueso
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBone.ParentBone">
            <summary>
                Hueso padre. Es null si no tiene
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalBoneAttach">
            <summary>
                Representa un modelo que se adjunta a un hueso del esqueleto, para que se modifique
                su ubicicación en el espacio en base a las transformaciones del hueso durante la animación.
                El modelo no debe ser transformado por afuera una vez que es adjuntado a un hueso.
                El renderizado del modelo debe hacerse por afuera de la animación esquelética.
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalBoneAttach.#ctor">
            <summary>
                Crear un modelo adjunto a un hueso, vacio
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalBoneAttach.#ctor(TGC.Core.SceneLoader.TgcMesh,TGC.Core.SkeletalAnimation.TgcSkeletalBone,Microsoft.DirectX.Matrix)">
            <summary>
                Crear un modelo adjunto a un hueso
            </summary>
            <param name="model">Modelo a adjuntar</param>
            <param name="bone">Hueso al cual adjuntarse</param>
            <param name="offset">Offset desde el cual el modelo sigue al hueso</param>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBoneAttach.Mesh">
            <summary>
                Modelo que se adjunta al hueso
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBoneAttach.Bone">
            <summary>
                Hueso al cual se le adjunta un modelo
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalBoneAttach.Offset">
            <summary>
                Desplazamiento desde el cual el modelo sigue al hueso
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalBoneAttach.setMesh(TGC.Core.SceneLoader.TgcMesh)">
            <summary>
                Configurar modelo
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalBoneAttach.updateValues">
            <summary>
                Actualiza los valores del Attachment en base a los parámetros configurados.
                Debe ejecutarse para que las modificaciones realmente se utilicen.
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalBoneAttach.updateMeshTransform(Microsoft.DirectX.Matrix)">
            <summary>
                Actualiza la transformacion del modelo en base al a transformacion actual
                del hueso y el offset configurado
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalLoader">
            <summary>
                Herramienta para cargar una Malla con animacion del tipo Skeletal Animation, segun formato TGC
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.#ctor">
            <summary>
                Crear un nuevo Loader
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.MeshFactory">
            <summary>
                Factory utilizado para crear una instancia de TgcSkeletalMesh.
                Por default se utiliza la clase DefaultMeshFactory.
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadMeshFromFile(System.String,System.String)">
            <summary>
                Carga un modelo a partir de un archivo
            </summary>
            <param name="filePath">Ubicacion del archivo XML</param>
            <param name="mediaPath">Path a partir del cual hay que buscar las Texturas</param>
            <returns>Modelo cargado</returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadMeshFromFile(System.String)">
            <summary>
                Carga un modelo a partir de un archivo.
                Se elige el directorio de texturas y recursos en base al directorio en el cual se encuntra el archivo del modelo.
            </summary>
            <param name="filePath">Ubicacion del archivo XML</param>
            <returns>Modelo cargado</returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadMeshAndAnimationsFromFile(System.String,System.String,System.String[])">
            <summary>
                Carga un modelo y un conjunto de animaciones a partir de varios archivos
            </summary>
            <param name="meshFilePath">Ubicacion del archivo XML del modelo</param>
            <param name="mediaPath">Path a partir del cual hay que buscar las Texturas</param>
            <param name="animationsFilePath">Array con ubicaciones de los archivos XML de cada animación</param>
            <returns>Modelo cargado con sus animaciones</returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadMeshAndAnimationsFromFile(System.String,System.String[])">
            <summary>
                Carga un modelo y un conjunto de animaciones a partir de varios archivos.
                Se elige el directorio de texturas y recursos en base al directorio en el cual se encuntra el archivo del modelo.
            </summary>
            <param name="meshFilePath">Ubicacion del archivo XML del modelo</param>
            <param name="animationsFilePath">Array con ubicaciones de los archivos XML de cada animación</param>
            <returns>Modelo cargado con sus animaciones</returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadMeshFromString(System.String,System.String)">
            <summary>
                Carga un modelo a partir del string del XML
            </summary>
            <param name="xmlString">contenido del XML</param>
            <param name="mediaPath">Path a partir del cual hay que buscar las Texturas</param>
            <returns>Modelo cargado</returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadAnimationFromFile(TGC.Core.SkeletalAnimation.TgcSkeletalMesh,System.String)">
            <summary>
                Carga una animación a un modelo ya cargado, en base a un archivo
                La animación se agrega al modelo.
            </summary>
            <param name="mesh">Modelo ya cargado</param>
            <param name="filePath">Ubicacion del archivo XML de la animación</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadAnimationFromString(TGC.Core.SkeletalAnimation.TgcSkeletalMesh,System.String)">
            <summary>
                Carga una animación a un modelo ya cargado, a partir del string del XML.
                La animación se agrega al modelo.
            </summary>
            <param name="mesh">Modelo ya cargado</param>
            <param name="xmlString">contenido del XML</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadMesh(TGC.Core.SkeletalAnimation.TgcSkeletalMeshData,System.String)">
            <summary>
                Carga un Modelo a partir de un objeto TgcSkeletalMeshData ya parseado
            </summary>
            <param name="meshData">Objeto con datos ya parseados</param>
            <param name="mediaPath">Path a partir del cual hay que buscar las Texturas</param>
            <returns>Modelo cargado</returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadAnimation(TGC.Core.SkeletalAnimation.TgcSkeletalMesh,TGC.Core.SkeletalAnimation.TgcSkeletalAnimationData)">
            <summary>
                Cargar estructura de animacion
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadSkeleton(TGC.Core.SkeletalAnimation.TgcSkeletalMeshData)">
            <summary>
                Cargar estructura de esqueleto
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.loadVerticesWeights(TGC.Core.SkeletalAnimation.TgcSkeletalMeshData,TGC.Core.SkeletalAnimation.TgcSkeletalBone[])">
            <summary>
                Cargar Weights de vertices
            </summary>
            <param name="meshData"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.crearMeshDiffuseMap(TGC.Core.SkeletalAnimation.TgcSkeletalLoader.TgcSkeletalLoaderMaterialAux[],TGC.Core.SkeletalAnimation.TgcSkeletalMeshData)">
            <summary>
                Crea un mesh con uno o varios DiffuseMap
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.crearMeshSoloColor(TGC.Core.SkeletalAnimation.TgcSkeletalMeshData)">
            <summary>
                Crea un mesh sin texturas, solo con VertexColors
            </summary>
            <param name="meshData"></param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.createTextureAndMaterial(TGC.Core.SceneLoader.TgcMaterialData,System.String)">
            <summary>
                Crea Material y Textura
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.TgcSkeletalLoaderMaterialAux">
            <summary>
                Estructura auxiliar para cargar SubMaterials y Texturas
            </summary>
        </member>
        <member name="F:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.VertexColorVertexElements">
            <summary>
                FVF para formato de malla VERTEX_COLOR
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.VertexColorVertex">
            <summary>
                Estructura de Vertice para formato de malla VERTEX_COLOR
            </summary>
        </member>
        <member name="F:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.DiffuseMapVertexElements">
            <summary>
                FVF para formato de malla DIFFUSE_MAP
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.DiffuseMapVertex">
            <summary>
                Estructura de Vertice para formato de malla DIFFUSE_MAP
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.IMeshFactory">
            <summary>
                Factory para permitir crear una instancia especifica de la clase TgcMesh
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.IMeshFactory.createNewMesh(Microsoft.DirectX.Direct3D.Mesh,System.String,TGC.Core.SkeletalAnimation.TgcSkeletalMesh.MeshRenderType,TGC.Core.SkeletalAnimation.TgcSkeletalBone[])">
            <summary>
                Crear una nueva instancia de la clase TgcSkeletalMesh o derivados
            </summary>
            <param name="d3dMesh">Mesh de Direct3D</param>
            <param name="meshName">Nombre de la malla</param>
            <param name="renderType">Tipo de renderizado de la malla</param>
            <param name="bones">Huesos de la malla</param>
            <returns>Instancia de TgcMesh creada</returns>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalLoader.DefaultMeshFactory">
            <summary>
                Factory default que crea una instancia de la clase TgcMesh
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalMesh">
            <summary>
                Malla que representa un modelo 3D con varias animaciones, animadas por Skeletal Animation
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.MeshRenderType">
            <summary>
                Tipos de de renderizado de mallas
            </summary>
        </member>
        <member name="F:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.MeshRenderType.VERTEX_COLOR">
            <summary>
                Solo colores por vertice
            </summary>
        </member>
        <member name="F:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.MeshRenderType.DIFFUSE_MAP">
            <summary>
                Solo un canal de textura en DiffuseMap
            </summary>
        </member>
        <member name="F:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.MAX_BONE_COUNT">
            <summary>
                Maxima cantidad de huesos soportados por TgcSkeletalMesh
                Coincide con el tamaño del array de matrices que se envia
                al VertexShader para hacer skinning.
            </summary>
        </member>
        <member name="F:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.d3dMesh">
            <summary>
                Mesh de DirectX
            </summary>
        </member>
        <member name="F:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.staticMeshBoundingBox">
            <summary>
                BoundingBox de la malla sin ninguna animación.
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.#ctor">
            <summary>
                Constructor vacio, para facilitar la herencia de esta clase.
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.#ctor(Microsoft.DirectX.Direct3D.Mesh,System.String,TGC.Core.SkeletalAnimation.TgcSkeletalMesh.MeshRenderType,TGC.Core.SkeletalAnimation.TgcSkeletalBone[])">
            <summary>
                Crea una nueva malla.
            </summary>
            <param name="mesh">Mesh de DirectX</param>
            <param name="renderType">Formato de renderizado de la malla</param>
            <param name="bones">Datos de los huesos</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.#ctor(System.String,TGC.Core.SkeletalAnimation.TgcSkeletalMesh,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una nueva malla que es una instancia de otra malla original.
                Reutiliza toda la geometría de la malla original sin duplicarla.
                Debe crearse luego de haber cargado todas las animaciones en la malla original
            </summary>
            <param name="name">Nombre de la malla</param>
            <param name="parentInstance">Malla original desde la cual basarse</param>
            <param name="translation">Traslación respecto de la malla original</param>
            <param name="rotation">Rotación respecto de la malla original</param>
            <param name="scale">Escala respecto de la malla original</param>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.D3dMesh">
            <summary>
                Mesh interna de DirectX
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Name">
            <summary>
                Nombre de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Materials">
            <summary>
                Array de Materials
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.DiffuseMaps">
            <summary>
                Array de texturas para DiffuseMap
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Enabled">
            <summary>
                Indica si la malla esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.BoundingBox">
            <summary>
                BoundingBox del Mesh.
                Puede variar según la animación que tiene configurada en el momento.
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.RenderType">
            <summary>
                Tipo de formato de Render de esta malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.VertexDeclaration">
            <summary>
                VertexDeclaration del Flexible Vertex Format (FVF) usado por la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.AutoUpdateBoundingBox">
            <summary>
                Indica si se actualiza automaticamente el BoundingBox con cada movimiento de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Bones">
            <summary>
                Huesos del esqueleto de la malla. Ordenados en forma jerárquica
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Animations">
            <summary>
                Mapa de animaciones de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.CurrentAnimation">
            <summary>
                Animación actual de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.FrameRate">
            <summary>
                Velocidad de la animacion medida en cuadros por segundo.
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.CurrentFrame">
            <summary>
                Cuadro actual de animacion
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.IsAnimating">
            <summary>
                Indica si actualmente hay una animación en curso.
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.PlayLoop">
            <summary>
                Indica si la animación actual se ejecuta con un Loop
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Attachments">
            <summary>
                Modelos adjuntados para seguir la trayectoria de algún hueso
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.ParentInstance">
            <summary>
                Original desde el cual esta malla fue clonada.
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.MeshInstances">
            <summary>
                Lista de mallas que fueron clonadas a partir de este original
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.NumberTriangles">
            <summary>
                Cantidad de triángulos de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.NumberVertices">
            <summary>
                Cantidad de vértices de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.RenderSkeleton">
            <summary>
                En true renderiza solo el esqueleto del modelo, en lugar de la malla.
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.render">
            <summary>
                Renderiza la malla, si esta habilitada.
                Para que haya animacion se tiene que haber seteado una y haber
                llamado previamente al metodo updateAnimation()
                Sino se renderiza la pose fija de la malla
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.dispose">
            <summary>
                Libera los recursos de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Transform">
            <summary>
                Matriz final que se utiliza para aplicar transformaciones a la malla.
                Si la propiedad AutoTransformEnable esta en True, la matriz se reconstruye en cada cuadro
                en base a los valores de: Position, Rotation, Scale.
                Si AutoTransformEnable está en False, se respeta el valor que el usuario haya cargado en la matriz.
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.AutoTransformEnable">
            <summary>
                En True hace que la matriz de transformacion (Transform) de la malla se actualiza en
                cada cuadro en forma automática, según los valores de: Position, Rotation, Scale.
                En False se respeta lo que el usuario haya cargado a mano en la matriz.
                Por default está en True.
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Position">
            <summary>
                Posicion absoluta de la Malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Rotation">
            <summary>
                Rotación absoluta de la malla
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.Scale">
            <summary>
                Escalado absoluto de la malla;
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.move(Microsoft.DirectX.Vector3)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.move(System.Single,System.Single,System.Single)">
            <summary>
                Desplaza la malla la distancia especificada, respecto de su posicion actual
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.moveOrientedY(System.Single)">
            <summary>
                Mueve la malla en base a la orientacion actual de rotacion.
                Es necesario rotar la malla primero
            </summary>
            <param name="movement">Desplazamiento. Puede ser positivo (hacia adelante) o negativo (hacia atras)</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.getPosition(Microsoft.DirectX.Vector3)">
            <summary>
                Obtiene la posicion absoluta de la malla, recibiendo un vector ya creado para
                almacenar el resultado
            </summary>
            <param name="pos">Vector ya creado en el que se carga el resultado</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.rotateX(System.Single)">
            <summary>
                Rota la malla respecto del eje X
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.rotateY(System.Single)">
            <summary>
                Rota la malla respecto del eje Y
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.rotateZ(System.Single)">
            <summary>
                Rota la malla respecto del eje Z
            </summary>
            <param name="angle">Ángulo de rotación en radianes</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.initData(Microsoft.DirectX.Direct3D.Mesh,System.String,TGC.Core.SkeletalAnimation.TgcSkeletalMesh.MeshRenderType,TGC.Core.SkeletalAnimation.TgcSkeletalBone[])">
            <summary>
                Cargar datos iniciales
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.setupSkeleton">
            <summary>
                Configuracion inicial del esquleto
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.buildSkletonMesh">
            <summary>
                Crea mallas a modo Debug para visualizar la configuración del esqueleto
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.playAnimation(System.String,System.Boolean,System.Single)">
            <summary>
                Establece cual es la animacion activa de la malla.
                Si la animacion activa es la misma que ya esta siendo animada actualmente, no se para ni se reinicia.
                Para forzar que se reinicie es necesario hacer stopAnimation()
            </summary>
            <param name="animationName">Nombre de la animacion a activar</param>
            <param name="playLoop">Indica si la animacion vuelve a comenzar al terminar</param>
            <param name="userFrameRate">FrameRate personalizado. Con -1 se utiliza el default de la animación</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.playAnimation(System.String,System.Boolean)">
            <summary>
                Establece cual es la animacion activa de la malla.
                Si la animacion activa es la misma que ya esta siendo animada actualmente, no se para ni se reinicia.
                Para forzar que se reinicie es necesario hacer stopAnimation().
                Utiliza el FrameRate default de cada animación
            </summary>
            <param name="animationName">Nombre de la animacion a activar</param>
            <param name="playLoop">Indica si la animacion vuelve a comenzar al terminar</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.playAnimation(System.String)">
            <summary>
                Establece cual es la animacion activa de la malla.
                Si la animacion activa es la misma que ya esta siendo animada actualmente, no se para ni se reinicia.
                Para forzar que se reinicie es necesario hacer stopAnimation().
                Se reproduce con loop.
                Utiliza el FrameRate default de cada animación
            </summary>
            <param name="animationName">Nombre de la animacion a activar</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.initAnimationSettings(System.String,System.Boolean,System.Single)">
            <summary>
                Prepara una nueva animacion para ser ejecutada
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.stopAnimation">
            <summary>
                Desactiva la animacion actual
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.updateAnimation(System.Single)">
            <summary>
                Actualiza el cuadro actual de la animacion.
                Debe ser llamado en cada cuadro antes de Render()
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.updateSkeleton">
            <summary>
                Actualiza la posicion de cada hueso del esqueleto segun sus KeyFrames de la animacion
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.getCurrentFrameBone(System.Collections.Generic.List{TGC.Core.SkeletalAnimation.TgcSkeletalAnimationFrame},System.Single)">
            <summary>
                Obtener el KeyFrame correspondiente a cada hueso segun el tiempo transcurrido
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.updateMeshVertices">
            <summary>
                Actualizar los vertices de la malla segun las posiciones del los huesos del esqueleto
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.setShaderMatrix">
            <summary>
                Cargar todas la matrices que necesita el shader
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.UpdateMeshTransform">
            <summary>
                Actualiza la matriz de transformacion con los datos internos del mesh (scale. rotation, traslation) para casos complejos es mejor no utilizar este metodo.
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.activateAlphaBlend">
            <summary>
                Activar AlphaBlending, si corresponde
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.resetAlphaBlend">
            <summary>
                Desactivar AlphaBlending
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.renderSkeletonMesh">
            <summary>
                Dibujar el esqueleto de la malla
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.animateAndRender(System.Single)">
            <summary>
                Actualiza el cuadro actual de animacion y renderiza la malla.
                Es equivalente a llamar a updateAnimation() y luego a Render()
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.getVertexPositions">
            <summary>
                Devuelve un array con todas las posiciones de los vértices de la malla, en el estado actual
            </summary>
            <returns>Array creado</returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.computeNormals">
            <summary>
                Recalcula todas las normales del mesh
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.createBoundingBox">
            <summary>
                Calcula el BoundingBox de la malla, en base a todos sus vertices.
                Llamar a este metodo cuando ha cambiado la estructura interna de la malla.
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.updateBoundingBox">
            <summary>
                Actualiza el BoundingBox de la malla, en base a su posicion actual.
                Solo contempla traslacion y escalado
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.setColor(System.Drawing.Color)">
            <summary>
                Cambia el color de todos los vértices de la malla, actualizando el VertexBuffer
                En modelos complejos puede resultar una operación poco performante.
                La actualización será visible la próxima vez que se haga updateAnimation().
                Si hay instnacias de este modelo, sea el original o una copia, todos los demás se verán
                afectados
            </summary>
            <param name="color">Color nuevo</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.changeDiffuseMaps(TGC.Core.Textures.TgcTexture[])">
            <summary>
                Permite cambiar las texturas de DiffuseMap de esta malla
            </summary>
            <param name="newDiffuseMaps">Array de nuevas texturas. Tiene que tener la misma cantidad que el original</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.getBoneByName(System.String)">
            <summary>
                Busca el hueso con el nombre especificado.
            </summary>
            <param name="boneName">Nombre del hueso buscado</param>
            <returns>Hueso encontrado o null si no lo encontró</returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.createMeshInstance(System.String,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Crea una nueva malla que es una instancia de esta malla original
                Reutiliza toda la geometría de la malla original sin duplicarla.
                Solo se puede crear instancias a partir de originales.
                Se debe crear después de haber agregado todas las animaciones al original.
                Los attachments de la malla original se duplican.
            </summary>
            <param name="name">Nombre de la malla</param>
            <param name="translation">Traslación respecto de la malla original</param>
            <param name="rotation">Rotación respecto de la malla original</param>
            <param name="scale">Escala respecto de la malla original</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.createMeshInstance(System.String)">
            <summary>
                Crea una nueva malla que es una instancia de esta malla original
                Reutiliza toda la geometría de la malla original sin duplicarla.
                Solo se puede crear instancias a partir de originales.
                Se debe crear después de haber agregado todas las animaciones al original.
                Los attachments de la malla original se duplican.
            </summary>
            <param name="name">Nombre de la malla</param>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.AnimationEndsHandler">
            <summary>
                Indica que la animación actual ha finalizado.
                Se llama cuando se acabaron los frames de la animación.
                Si se anima en Loop, se llama cada vez que termina.
            </summary>
            <param name="mesh">Malla animada</param>
        </member>
        <member name="E:TGC.Core.SkeletalAnimation.TgcSkeletalMesh.AnimationEnds">
            <summary>
                Evento que se llama cada vez que la animación actual finaliza.
                Se llama cuando se acabaron los frames de la animación.
                Si se anima en Loop, se llama cada vez que termina.
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalMeshData">
            <summary>
                Información de la Malla de un modelo animado por Animación Esquelética
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalParser">
            <summary>
                Parser de archivos XML de formato TGC para TgcSkeletalAnimation
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalParser.parseMeshFromString(System.String)">
            <summary>
                Levanta la informacion del mesh a partir de un XML
            </summary>
            <param name="xmlString">contenido del XML</param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalParser.parseStandardMaterial(TGC.Core.SceneLoader.TgcMaterialData,System.Xml.XmlElement)">
            <summary>
                Parsear Standard Material
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalParser.parseAnimationFromString(System.String)">
            <summary>
                Levanta la informacion de una animacion a partir del XML
            </summary>
            <param name="xmlString">Contenido que el XML</param>
            <returns>Información parseada</returns>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalVertexWeight">
            <summary>
                Influencias de huesos sobre un vertice.
                Un vertice puede estar influenciado por mas de un hueso
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalVertexWeight.Weights">
            <summary>
                Influencias del vertice
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalVertexWeight.createVector4WeightsAndIndices(Microsoft.DirectX.Vector4@,Microsoft.DirectX.Vector4@)">
            <summary>
                Convierte los weights del vertice en dos Vector4, uno con los valores de los weights y otro con los indices de los
                huesos.
                Si tiene menos de 4 weights completa con 0.
            </summary>
            <param name="vector4">Valores de Weights</param>
            <param name="vector4_2">Indices de huesos</param>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalVertexWeight.getBlendIndex(System.Int32)">
            <summary>
                Obtener indice de hueso para el weight numero n.
                Devuelve 0 si no hay
            </summary>
        </member>
        <member name="M:TGC.Core.SkeletalAnimation.TgcSkeletalVertexWeight.getBlendWeight(System.Int32)">
            <summary>
                Obtener valor de influencia para el weight numero n.
                Devuelve 0 si no hay
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalVertexWeight.BoneWeight">
            <summary>
                Influencia de un hueso sobre un vertice
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalVertexWeight.BoneWeight.Bone">
            <summary>
                Hueso que influye
            </summary>
        </member>
        <member name="P:TGC.Core.SkeletalAnimation.TgcSkeletalVertexWeight.BoneWeight.Weight">
            <summary>
                Influencia del hueso sobre el vertice. Valor normalizado entre 0 y 1
            </summary>
        </member>
        <member name="T:TGC.Core.SkeletalAnimation.TgcSkeletalVertexWeight.BoneWeight.GreaterComparer">
            <summary>
                Comparador segun weight
            </summary>
        </member>
        <member name="T:TGC.Core.Sound.Tgc3dSound">
            <summary>
                Herramienta para reproducir un sonido WAV en 3D, variando como suena respecto de su posición
                en el espacio.
                Solo se pueden cargar sonidos WAV que sean MONO (1 channel).
                Sonidos stereos (2 channels) no pueden ser utilizados.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.Tgc3dSound.#ctor(System.String,Microsoft.DirectX.Vector3,Microsoft.DirectX.DirectSound.Device)">
            <summary>
                Crea un sonido 3D
                Solo se pueden cargar sonidos WAV que sean MONO (1 channel).
                Sonidos stereos (2 channels) no pueden ser utilizados.
            </summary>
            <param name="soundPath">Path del archivo WAV</param>
            <param name="position">Posicion del sonido en el espacio</param>
        </member>
        <member name="P:TGC.Core.Sound.Tgc3dSound.SoundBuffer">
            <summary>
                Buffer con la información del sonido cargado
            </summary>
        </member>
        <member name="P:TGC.Core.Sound.Tgc3dSound.Buffer3d">
            <summary>
                Buffer que manipula la parte 3D del sonido cargado
            </summary>
        </member>
        <member name="P:TGC.Core.Sound.Tgc3dSound.Position">
            <summary>
                Posición del sonido dentro del espacio.
                La forma de escuchar el sonido varia según esta ubicación y la posición
                del Listener3D de sonidos.
            </summary>
        </member>
        <member name="P:TGC.Core.Sound.Tgc3dSound.MinDistance">
            <summary>
                Mínima distancia a partir de la cual el sonido 3D comienza a atenuarse respecto de la posicion
                del Listener3D
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.Tgc3dSound.loadSound(System.String,System.Int32,Microsoft.DirectX.DirectSound.Device)">
            <summary>
                Carga un archivo WAV de audio, indicando el volumen del mismo
                Solo se pueden cargar sonidos WAV que sean MONO (1 channel).
                Sonidos stereos (2 channels) no pueden ser utilizados.
            </summary>
            <param name="soundPath">Path del archivo WAV</param>
            <param name="volume">Volumen del mismo</param>
        </member>
        <member name="M:TGC.Core.Sound.Tgc3dSound.loadSound(System.String,Microsoft.DirectX.DirectSound.Device)">
            <summary>
                Carga un archivo WAV de audio, con el volumen default del mismo
                Solo se pueden cargar sonidos WAV que sean MONO (1 channel).
                Sonidos stereos (2 channels) no pueden ser utilizados.
            </summary>
            <param name="soundPath">Path del archivo WAV</param>
        </member>
        <member name="M:TGC.Core.Sound.Tgc3dSound.play(System.Boolean)">
            <summary>
                Reproduce el sonido, indicando si se hace con Loop.
                Si ya se está reproduciedo, no vuelve a empezar.
            </summary>
            <param name="playLoop">TRUE para reproducir en loop</param>
        </member>
        <member name="M:TGC.Core.Sound.Tgc3dSound.play">
            <summary>
                Reproduce el sonido, sin Loop.
                Si ya se está reproduciedo, no vuelve a empezar.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.Tgc3dSound.stop">
            <summary>
                Pausa la ejecución del sonido.
                Si el sonido no se estaba ejecutando, no hace nada.
                Si se hace stop() y luego play(), el sonido continua desde donde había dejado la última vez.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.Tgc3dSound.dispose">
            <summary>
                Liberar recursos del sonido
            </summary>
        </member>
        <member name="T:TGC.Core.Sound.TgcDirectSound">
            <summary>
                Herramienta para manipular el Device de DirectSound
            </summary>
        </member>
        <member name="P:TGC.Core.Sound.TgcDirectSound.DsDevice">
            <summary>
                Device de DirectSound
            </summary>
        </member>
        <member name="P:TGC.Core.Sound.TgcDirectSound.Listener3d">
            <summary>
                Representa el objeto central del universo 3D que escucha todos los demás sonidos.
                En base a su posición varía la captación de todos los demas sonidos 3D.
            </summary>
        </member>
        <member name="P:TGC.Core.Sound.TgcDirectSound.ListenerTracking">
            <summary>
                Objeto al cual el Listener3D va a seguir para variar su posición en cada cuadro.
                Solo puede haber un objeto que está siendo seguido por el Listener3D a la vez.
                En caso de haber configurado un objeto a seguir, el Listener3D actualiza su posición en forma
                automática en cada cuadro.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcDirectSound.UpdateListener3d">
            <summary>
                Actualiza la posición del Listener3D en base al ListenerTracking
            </summary>
        </member>
        <member name="T:TGC.Core.Sound.TgcMp3Player">
            <summary>
                Herramienta para reproducir archivos MP3s
            </summary>
        </member>
        <member name="T:TGC.Core.Sound.TgcMp3Player.States">
            <summary>
                Estados del reproductor
            </summary>
        </member>
        <member name="P:TGC.Core.Sound.TgcMp3Player.FileName">
            <summary>
                Path del archivo a reproducir
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.play(System.Boolean)">
            <summary>
                Inicia la reproducción del archivo MP3.
                <param name="playLoop">True para reproducir en loop</param>
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.pause">
            <summary>
                Pausa la reproducción en proceso.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.resume">
            <summary>
                Continúa con la reproducción actual.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.stop">
            <summary>
                Detiene la reproducción del archivo de audio.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.closeFile">
            <summary>
                Detiene la reproducción actual y cierra el archivo de audio.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.getStatus">
            <summary>
                Obtiene el estado de la reproducción en proceso.
            </summary>
            <returns>Estado del reproducto</returns>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.goToBeginning">
            <summary>
                Mueve el apuntador de archivo al inicio del mismo.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.goToEnd">
            <summary>
                Mueve el apuntador de archivo al final del mismo.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.NombreCorto(System.String)">
            <summary>
                Método para convertir un nombre de archivo largo en uno corto,
                necesario para usarlo como parámetro de la función MciSendString.
            </summary>
            <param name="nombreLargo">Nombre y ruta del archivo a convertir.</param>
            <returns>Nombre corto del archivo especificado.</returns>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.NombreLargo(System.String)">
            <summary>
                Método que convierte un nombre de archivo corto, en uno largo.
            </summary>
            <param name="NombreCorto">Nombre del archivo a convertir.</param>
            <returns>Cadena con el nombre de archivo resultante.</returns>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.MciMensajesDeError(System.Int32)">
            <summary>
                Método para convertir los mensajes de error numéricos, generados por la
                función mciSendString, en su correspondiente cadena de caracteres.
            </summary>
            <param name="ErrorCode">
                Código de error devuelto por la función
                mciSendString
            </param>
            <returns>Cadena de tipo string, con el mensaje de error</returns>
        </member>
        <member name="M:TGC.Core.Sound.TgcMp3Player.LoadFile">
            <summary>
                Abre el archivo MP3 específicado.
            </summary>
            <returns>
                Verdadero si se tuvo éxito al abrir el archivo
                falso en caso contrario.
            </returns>
        </member>
        <member name="T:TGC.Core.Sound.TgcStaticSound">
            <summary>
                Herramienta para reproducir un sonido WAV estático
            </summary>
        </member>
        <member name="P:TGC.Core.Sound.TgcStaticSound.SoundBuffer">
            <summary>
                Buffer con la información del sonido cargado
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcStaticSound.loadSound(System.String,System.Int32,Microsoft.DirectX.DirectSound.Device)">
            <summary>
                Carga un archivo WAV de audio, indicando el volumen del mismo
            </summary>
            <param name="soundPath">Path del archivo WAV</param>
            <param name="volume">Volumen del mismo</param>
        </member>
        <member name="M:TGC.Core.Sound.TgcStaticSound.loadSound(System.String,Microsoft.DirectX.DirectSound.Device)">
            <summary>
                Carga un archivo WAV de audio, con el volumen default del mismo
            </summary>
            <param name="soundPath">Path del archivo WAV</param>
        </member>
        <member name="M:TGC.Core.Sound.TgcStaticSound.play(System.Boolean)">
            <summary>
                Reproduce el sonido, indicando si se hace con Loop.
                Si ya se está reproduciedo, no vuelve a empezar.
            </summary>
            <param name="playLoop">TRUE para reproducir en loop</param>
        </member>
        <member name="M:TGC.Core.Sound.TgcStaticSound.play">
            <summary>
                Reproduce el sonido, sin Loop.
                Si ya se está reproduciedo, no vuelve a empezar.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcStaticSound.stop">
            <summary>
                Pausa la ejecución del sonido.
                Si el sonido no se estaba ejecutando, no hace nada.
                Si se hace stop() y luego play(), el sonido continua desde donde había dejado la última vez.
            </summary>
        </member>
        <member name="M:TGC.Core.Sound.TgcStaticSound.dispose">
            <summary>
                Liberar recursos del sonido
            </summary>
        </member>
        <member name="T:TGC.Core.Terrain.TgcSimpleTerrain">
            <summary>
                Permite crear la malla de un terreno en base a una textura de Heightmap
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSimpleTerrain.HeightmapData">
            <summary>
                Valor de Y para cada par (X,Z) del Heightmap
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSimpleTerrain.Enabled">
            <summary>
                Indica si la malla esta habilitada para ser renderizada
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSimpleTerrain.Center">
            <summary>
                Centro del terreno
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSimpleTerrain.Effect">
            <summary>
                Shader del mesh
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSimpleTerrain.Technique">
            <summary>
                Technique que se va a utilizar en el effect.
                Cada vez que se llama a Render() se carga este Technique (pisando lo que el shader ya tenia seteado)
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSimpleTerrain.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSimpleTerrain.render">
            <summary>
                Renderiza el terreno
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSimpleTerrain.dispose">
            <summary>
                Libera los recursos del Terreno
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSimpleTerrain.loadHeightmap(System.String,System.Single,System.Single,Microsoft.DirectX.Vector3)">
            <summary>
                Crea la malla de un terreno en base a un Heightmap
            </summary>
            <param name="heightmapPath">Imagen de Heightmap</param>
            <param name="scaleXZ">Escala para los ejes X y Z</param>
            <param name="scaleY">Escala para el eje Y</param>
            <param name="center">Centro de la malla del terreno</param>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSimpleTerrain.loadTexture(System.String)">
            <summary>
                Carga la textura del terreno
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSimpleTerrain.loadHeightMap(Microsoft.DirectX.Direct3D.Device,System.String)">
            <summary>
                Carga los valores del Heightmap en una matriz
            </summary>
        </member>
        <member name="T:TGC.Core.Terrain.TgcSkyBox">
            <summary>
                Herramienta para crear un SkyBox conformado por un cubo de 6 caras, cada cada con su
                propia textura.
                Luego de creado, si se modifica cualquier valor del mismo, se debe llamar a updateValues()
                para que tome efecto.
            </summary>
        </member>
        <member name="T:TGC.Core.Terrain.TgcSkyBox.SkyFaces">
            <summary>
                Caras del SkyBox
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.#ctor">
            <summary>
                Crear un SkyBox vacio
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSkyBox.SkyEpsilon">
            <summary>
                Valor de desplazamiento utilizado para que las caras del SkyBox encajen bien entre sí.
                Llamar a InitSkyBox() para aplicar cambios.
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSkyBox.Size">
            <summary>
                Tamaño del SkyBox.
                Llamar a InitSkyBox() para aplicar cambios.
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSkyBox.Center">
            <summary>
                Centro del SkyBox al cambiar el centro se cambia la matriz traslacion.
                Esto hace que en render se trasladen las caras, utilizado para que un skybox siga al personaje.
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSkyBox.Color">
            <summary>
                Color del SkyBox.
                Llamar a InitSkyBox() para aplicar cambios.
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSkyBox.Faces">
            <summary>
                Meshes de cada una de las 6 caras del cubo, en el orden en que se enumeran en SkyFaces.
                Las mismas se inicializan con InitSkyBox();
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSkyBox.FaceTextures">
            <summary>
                Path de las texturas de cada una de las 6 caras del cubo, en el orden en que se enumeran en SkyFaces
                Para actualizarlas se debe llamar setFaceTexture y luego InitSkyBox();
            </summary>
        </member>
        <member name="P:TGC.Core.Terrain.TgcSkyBox.AlphaBlendEnable">
            <summary>
                Habilita el renderizado con AlphaBlending para los modelos
                con textura o colores por vértice de canal Alpha.
                Por default está deshabilitado.
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.render">
            <summary>
                Render del SkyBox
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.dispose">
            <summary>
                Liberar recursos del SkyBox
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.setFaceTexture(TGC.Core.Terrain.TgcSkyBox.SkyFaces,System.String)">
            <summary>
                Configurar la textura de una cara del SkyBox.
                Para aplicar los cambios se debe llamar InitSkyBox.
            </summary>
            <param name="face">Cara del SkyBox</param>
            <param name="texturePath">Path de la textura</param>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.Init">
            <summary>
                Tomar los valores configurados y crear el SkyBox. Solo invocar en tiempo de INIT!!!
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.cargarVertices(TGC.Core.Terrain.TgcSkyBox.SkyFaces,Microsoft.DirectX.GraphicsStream,System.Int32)">
            <summary>
                Crear Vertices segun la cara pedida
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.cargarVerticesUp(Microsoft.DirectX.GraphicsStream,System.Int32)">
            <summary>
                Crear vertices para la cara Up
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.cargarVerticesDown(Microsoft.DirectX.GraphicsStream,System.Int32)">
            <summary>
                Crear vertices para la cara Down
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.cargarVerticesFront(Microsoft.DirectX.GraphicsStream,System.Int32)">
            <summary>
                Crear vertices para la cara Front
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.cargarVerticesBack(Microsoft.DirectX.GraphicsStream,System.Int32)">
            <summary>
                Crear vertices para la cara Back
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.cargarVerticesRight(Microsoft.DirectX.GraphicsStream,System.Int32)">
            <summary>
                Crear vertices para la cara Right
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.cargarVerticesLeft(Microsoft.DirectX.GraphicsStream,System.Int32)">
            <summary>
                Crear vertices para la cara Left
            </summary>
        </member>
        <member name="M:TGC.Core.Terrain.TgcSkyBox.cargarIndices(System.Int16[])">
            <summary>
                Generar array de indices
            </summary>
        </member>
        <member name="T:TGC.Core.Textures.TexturesManager">
            <summary>
                Herrramienta para administrar las texturas cargadas en el Device.
                Antes evita hacer device.SetTexture() innecesarios, dado que es una operación
                bastante costosa.
                Pero ahora quedo deprecada esa parte, porque DirectX hace ese control internamente y no
                tiene sentido hacerlo.
            </summary>
        </member>
        <member name="F:TGC.Core.Textures.TexturesManager.DIRECTX_MULTITEXTURE_COUNT">
            <summary>
                Cantidad de texturas simultaneas soportadas por DirectX
            </summary>
        </member>
        <member name="P:TGC.Core.Textures.TexturesManager.Instance">
            <summary>
                Permite acceder a una instancia de la clase TexturesManager desde cualquier parte del codigo.
            </summary>
        </member>
        <member name="M:TGC.Core.Textures.TexturesManager.set(System.Int32,TGC.Core.Textures.TgcTexture)">
            <summary>
                Carga una textura en el Stage especificado.
                Si la textura es null, es similar aa hacer clear()
            </summary>
            <param name="stage">Stage en el cual configurar la textura</param>
            <param name="texture">Textura a configurar</param>
        </member>
        <member name="M:TGC.Core.Textures.TexturesManager.shaderSet(Microsoft.DirectX.Direct3D.Effect,System.String,TGC.Core.Textures.TgcTexture)">
            <summary>
                Carga una textura como parámetro de un Shader
            </summary>
            <param name="effect">Shader</param>
            <param name="parameterName">Nombre del parámetro en el Shader</param>
            <param name="texture">Textura a aplicar</param>
        </member>
        <member name="M:TGC.Core.Textures.TexturesManager.clear(System.Int32)">
            <summary>
                Limpiar la textura de un Stage particular
            </summary>
        </member>
        <member name="M:TGC.Core.Textures.TexturesManager.clearAll">
            <summary>
                Limpiar las texturas de todos los Stages
            </summary>
        </member>
        <member name="T:TGC.Core.Textures.TexturesPool">
            <summary>
                TexturesPool para reutilizar texturas de igual path
            </summary>
        </member>
        <member name="P:TGC.Core.Textures.TexturesPool.Instance">
            <summary>
                Permite acceder a una instancia de la clase TexturesPool desde cualquier parte del codigo.
            </summary>
        </member>
        <member name="M:TGC.Core.Textures.TexturesPool.createTexture(Microsoft.DirectX.Direct3D.Device,System.String)">
            <summary>
                Agrega una textura al pool.
                Si no existe la crea. Sino reutiliza una existente.
            </summary>
        </member>
        <member name="M:TGC.Core.Textures.TexturesPool.createTexture(Microsoft.DirectX.Direct3D.Device,System.String,Microsoft.DirectX.Direct3D.Texture)">
            <summary>
                Agrega una textura al pool.
                Si no existe la crea. Sino reutiliza una existente.
            </summary>
        </member>
        <member name="M:TGC.Core.Textures.TexturesPool.disposeTexture(System.String)">
            <summary>
                Hace Dispose de una textura del pool, pero solo si nadie mas la está utilizando.
            </summary>
            <returns>True si se hizo un Dispose físico</returns>
        </member>
        <member name="M:TGC.Core.Textures.TexturesPool.clearAll">
            <summary>
                Limpia todos los elementos del pool
            </summary>
        </member>
        <member name="T:TGC.Core.Textures.TexturesPool.PoolItem">
            <summary>
                Item con informacion de la textura
            </summary>
        </member>
        <member name="T:TGC.Core.Textures.TgcTexture">
            <summary>
                Encapsula una textura de DirectX junto con información adicional
            </summary>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.#ctor(System.String,System.String,Microsoft.DirectX.Direct3D.Texture,System.Boolean)">
            <summary>
                Crear textura de TGC
            </summary>
        </member>
        <member name="P:TGC.Core.Textures.TgcTexture.FileName">
            <summary>
                Nombre del archivo de la textura. Ejemplo: miTextura.jpg
            </summary>
        </member>
        <member name="P:TGC.Core.Textures.TgcTexture.FilePath">
            <summary>
                Ruta de la textura. Ejemplo: C:\Texturas\miTextura.jpg
            </summary>
        </member>
        <member name="P:TGC.Core.Textures.TgcTexture.D3dTexture">
            <summary>
                Textura de DirectX
            </summary>
        </member>
        <member name="P:TGC.Core.Textures.TgcTexture.InPool">
            <summary>
                Indica si la textura fue creada dentro del TexturesPool de texturas del framework
            </summary>
        </member>
        <member name="P:TGC.Core.Textures.TgcTexture.Width">
            <summary>
                Ancho de la textura
            </summary>
        </member>
        <member name="P:TGC.Core.Textures.TgcTexture.Height">
            <summary>
                Alto de la textura
            </summary>
        </member>
        <member name="P:TGC.Core.Textures.TgcTexture.Size">
            <summary>
                Dimensiones de la textura
            </summary>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.getAspectRatio">
            <summary>
                Calcula el Aspect Ratio de la imagen
            </summary>
            <returns>Aspect Ratio</returns>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.dispose">
            <summary>
                Libera los recursos de la textura
            </summary>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.Clone">
            <summary>
                Crear una nueva textura igual a esta.
            </summary>
            <returns>Textura clonada</returns>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.createTexture(Microsoft.DirectX.Direct3D.Device,System.String,System.String)">
            <summary>
                Crea una nueva textura, haciendo el Loading del archivo de imagen especificado.
                Se utiliza un TexturesPool de Texturas para no cargar mas de una vez el mismo archivo.
            </summary>
            <param name="d3dDevice">Device de Direct3D</param>
            <param name="fileName">Nombre de la textura. Ejemplo: miTextura.jpg</param>
            <param name="filePath">Ruta completa de la textura. Ejemplo: C:\Texturas\miTextura.jpg</param>
            <returns>Textura creada</returns>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.createTexture(Microsoft.DirectX.Direct3D.Device,System.String)">
            <summary>
                Crea una nueva textura, haciendo el Loading del archivo de imagen especificado.
                Infiere el nombre de la textura en base al path completo
                Se utiliza un TexturesPool de Texturas para no cargar mas de una vez el mismo archivo.
            </summary>
            <param name="d3dDevice">Device de Direct3D</param>
            <param name="filePath">Ruta completa de la textura. Ejemplo: C:\Texturas\miTextura.jpg</param>
            <returns>Textura creada</returns>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.createTexture(System.String)">
            <summary>
                Crea una nueva textura, haciendo el Loading del archivo de imagen especificado.
                Infiere el nombre de la textura en base al path completo
                Se utiliza un TexturesPool de Texturas para no cargar mas de una vez el mismo archivo.
            </summary>
            <param name="filePath">Ruta completa de la textura. Ejemplo: C:\Texturas\miTextura.jpg</param>
            <returns>Textura creada</returns>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.createTexture(Microsoft.DirectX.Direct3D.Device,System.String,System.String,Microsoft.DirectX.Direct3D.Texture)">
            <summary>
                Crea una nueva textura, haciendo el Loading del archivo de imagen especificado.
                Se utiliza un TexturesPool de Texturas para no cargar mas de una vez el mismo archivo.
            </summary>
            <param name="d3dDevice">Device de Direct3D</param>
            <param name="fileName">Nombre de la textura. Ejemplo: miTextura.jpg</param>
            <param name="filePath">Ruta completa de la textura. Ejemplo: C:\Texturas\miTextura.jpg</param>
            <param name="d3dTexture">Textura de DirectX ya cargada por el usuario</param>
            <returns>Textura creada</returns>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.createTextureNoPool(Microsoft.DirectX.Direct3D.Device,System.String,System.String)">
            <summary>
                Crea una nueva textura, haciendo el Loading del archivo de imagen especificado.
                No se utiliza TexturesPool de Texturas. Se carga nuevamente cada una.
            </summary>
            <param name="d3dDevice">Device de Direct3D</param>
            <param name="fileName">Nombre de la textura. Ejemplo: miTextura.jpg</param>
            <param name="filePath">Ruta completa de la textura. Ejemplo: C:\Texturas\miTextura.jpg</param>
            <returns>Textura creada</returns>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.createTextureNoPool(Microsoft.DirectX.Direct3D.Device,System.String)">
            <summary>
                Crea una nueva textura, haciendo el Loading del archivo de imagen especificado.
                Infiere el nombre de la textura en base al path completo
                No se utiliza TexturesPool de Texturas. Se carga nuevamente cada una.
            </summary>
            <param name="d3dDevice">Device de Direct3D</param>
            <param name="filePath">Ruta completa de la textura. Ejemplo: C:\Texturas\miTextura.jpg</param>
            <returns>Textura creada</returns>
        </member>
        <member name="M:TGC.Core.Textures.TgcTexture.createTextureNoPool(System.String)">
            <summary>
                Crea una nueva textura, haciendo el Loading del archivo de imagen especificado.
                Infiere el nombre de la textura en base al path completo
                No se utiliza TexturesPool de Texturas. Se carga nuevamente cada una.
            </summary>
            <param name="filePath">Ruta completa de la textura. Ejemplo: C:\Texturas\miTextura.jpg</param>
            <returns>Textura creada</returns>
        </member>
        <member name="T:TGC.Core.TgcAxisLines">
            <summary>
                Herramienta para visualizar los ejes cartesianos
            </summary>
        </member>
        <member name="F:TGC.Core.TgcAxisLines.lineVertices">
            <summary>
                Vertices para dibujar los ejes cartesianos
            </summary>
        </member>
        <member name="M:TGC.Core.TgcAxisLines.render">
            <summary>
                Renderizar ejes segun posicion actual de la camara
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcBooleanModifier">
            <summary>
                Modificador para valores Boolean
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcButtonModifier">
            <summary>
                Modificador con un Boton
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcColorModifier">
            <summary>
                Modificador para elegir un color
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcEnumModifier">
            <summary>
                Modificador para un intervalo discreto de valores creados con una estructura Enum
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcEnumModifier.comboBox_SelectionChangeCommitted(System.Object,System.EventArgs)">
            <summary>
                Cuando el valor del combo cambia y fue confirmado realmente
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcFileModifier">
            <summary>
                Modificador para elegir un archivo del FileSystem
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcFloatModifier">
            <summary>
                Modificador para valores Float
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcIntervalModifier">
            <summary>
                Modificador para un intervalo discreto de valores
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcIntervalModifier.comboBox_SelectionChangeCommitted(System.Object,System.EventArgs)">
            <summary>
                Cuando el valor del combo cambia y fue confirmado realmente
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcIntModifier">
            <summary>
                Modificador para valores Int
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcMeshBrowser">
            <summary>
                Ventana visualizadora de TgcMesh de un directorio.
                Muestra la imagen de preview.jpg del TgcMesh (si tiene)
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Modifier.TgcMeshBrowser.HomeDirPath">
            <summary>
                Path del directorio Home
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Modifier.TgcMeshBrowser.SelectedMesh">
            <summary>
                Path del mesh seleccionado
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Modifier.TgcMeshBrowser.CurrentDir">
            <summary>
                Directorio actual del cual se van a cargar meshes.
                Al especificar un directorio se cargan todas los meshes que haya en el mismo.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcMeshBrowser.setSelectedMesh(System.String)">
            <summary>
                Carga todas los meshes del directorio padre en donde se encuentra el mesh especificada,
                y lo marca como mesh seleccionado de la ventana.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcMeshBrowser.loadFolderContent(System.String)">
            <summary>
                Cargar meshes del directorio especificado
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcMeshBrowser.buttonBrowse_Click(System.Object,System.EventArgs)">
            <summary>
                Clic en "Browse"
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcMeshBrowser.MeshItemControl">
            <summary>
                Control para una imagen o directorio
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcMeshBrowser.MeshItemControl.selectItem">
            <summary>
                Seleccionar item
            </summary>
        </member>
        <member name="F:TGC.Core.UserControls.Modifier.TgcMeshBrowser.components">
            <summary>
            Variable del diseñador requerida.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcMeshBrowser.Dispose(System.Boolean)">
            <summary>
            Limpiar los recursos que se estén utilizando.
            </summary>
            <param name="disposing">true si los recursos administrados se deben eliminar; false en caso contrario, false.</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcMeshBrowser.InitializeComponent">
            <summary>
            Método necesario para admitir el Diseñador. No se puede modificar
            el contenido del método con el editor de código.
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcModifierPanel">
            <summary>
                Panel generico para un Modifier
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Modifier.TgcModifierPanel.MainPanel">
            <summary>
                Control gráfico principal del Modifier
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Modifier.TgcModifierPanel.VarName">
            <summary>
                Nombre de la variable del Modifier
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifierPanel.getValue">
            <summary>
                Devuelve el valor del variable del modificador.
                Se debe castear al tipo que corresponda.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addFloat(System.String,System.Single,System.Single,System.Single)">
            <summary>
                Modificador para valores Float
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="minValue">Valor minimo</param>
            <param name="maxValue">Valor maximo</param>
            <param name="defaultValue">Valor default</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addInt(System.String,System.Int32,System.Int32,System.Int32)">
            <summary>
                Modificador para valores Int
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="minValue">Valor minimo</param>
            <param name="maxValue">Valor maximo</param>
            <param name="defaultValue">Valor default</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addBoolean(System.String,System.String,System.Boolean)">
            <summary>
                Modificador para valores Boolean
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="text">Descripcion</param>
            <param name="defaultValue">Valor default</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addColor(System.String,System.Drawing.Color)">
            <summary>
                Modificador para elegir un color
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="defaultValue">Valor default</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addInterval(System.String,System.Object[],System.Int32)">
            <summary>
                Modificador para un intervalo discreto de valores
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="values">Array de valores discretos</param>
            <param name="defaultIndex">Indice default del array</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addEnum(System.String,System.Type,System.Object)">
            <summary>
                Modificador para un intervalo discreto de valores creados con una estructura Enum
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="enumType">tipo del Enum a utilizar. Se obtiene con typeof(MyEnum)</param>
            <param name="defaultValue">variable del Enum que se carga como default. Ejemplo MyEnum.OpcionA</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addFile(System.String,System.String,System.String)">
            <summary>
                Modificador para elegir un archivo del FileSystem
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="defaultPath">path del archivo default</param>
            <param name="fileFilter">
                string que especifca el filtro de archivos.
                Ejemplo: .Imagenes JPG|*.jpg|Archivos XML|*.xml
                Enviar null si no se quiere filtro
            </param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addTexture(System.String,System.String)">
            <summary>
                Modificador para elegir una textura
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="values">path de la textura default</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addVertex3f(System.String,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Modificador para valores floats (X,Y,Z) de un vertice
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="minValue">Valor minimo</param>
            <param name="maxValue">Valor maximo</param>
            <param name="defaultValue">Valor default</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addVertex2f(System.String,Microsoft.DirectX.Vector2,Microsoft.DirectX.Vector2,Microsoft.DirectX.Vector2)">
            <summary>
                Modificador para valores floats (X,Y) o (U,V) de un vertice
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="minValue">Valor minimo</param>
            <param name="maxValue">Valor maximo</param>
            <param name="defaultValue">Valor default</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcModifiers.addButton(System.String,System.String,System.EventHandler)">
            <summary>
                Modificador que agrega un Boton
            </summary>
            <param name="varName">Nombre del modificador</param>
            <param name="text">Descripcion</param>
            <param name="defaultValue">Evento para manejer el click</param>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcTextureBrowser">
            <summary>
                Ventana visualizadora de imágenes de un directorio.
                Ideal para seleccionar texturas de un directorio.
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcTextureBrowser.CloseHandler">
            <summary>
                Delegate para cuando se cierra el popup (para AsyncModeEnable = true)
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcTextureBrowser.SelectImageHandler">
            <summary>
                Delegate para cuando seleccionan una imagen (para AsyncModeEnable = true)
            </summary>
        </member>
        <member name="F:TGC.Core.UserControls.Modifier.TgcTextureBrowser.FILE_EXT_SEARCH">
            <summary>
                Extensiones soportadas
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Modifier.TgcTextureBrowser.ShowFolders">
            <summary>
                En True carga tambien las carpetas de un directorio y permite navegar por ellas
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Modifier.TgcTextureBrowser.HomeDirPath">
            <summary>
                Path del directorio Home
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Modifier.TgcTextureBrowser.AsyncModeEnable">
            <summary>
                En True el popup se prepara para ser usada como no-bloqueante
                y usa el evento OnSelectImage para avisar que se hizo un cambio en la textura.
                Por default es False
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Modifier.TgcTextureBrowser.SelectedImage">
            <summary>
                Path de la imagen seleccionada
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Modifier.TgcTextureBrowser.CurrentDir">
            <summary>
                Directorio actual del cual se van a cargar imagenes.
                Al especificar un directorio se cargan todas las imágenes que haya en el mismo.
            </summary>
        </member>
        <member name="E:TGC.Core.UserControls.Modifier.TgcTextureBrowser.OnSelectImage">
            <summary>
                Evento para cuando seleccionan una imagen (para AsyncModeEnable = true)
            </summary>
        </member>
        <member name="E:TGC.Core.UserControls.Modifier.TgcTextureBrowser.OnClose">
            <summary>
                Evento para cuando se cierra el popup (para AsyncModeEnable = true)
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcTextureBrowser.setSelectedImage(System.String)">
            <summary>
                Carga todas las imágenes del directorio en donde se encuentra la imágen especificada,
                y la marca como la imágen seleccionada de la ventana.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcTextureBrowser.loadImages(System.String)">
            <summary>
                Cargar imagenes del directorio especificado
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcTextureBrowser.ImageControl">
            <summary>
                Control para una imagen o directorio
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcTextureBrowser.ImageControl.selectImage">
            <summary>
                Seleccionar imagen
            </summary>
        </member>
        <member name="F:TGC.Core.UserControls.Modifier.TgcTextureBrowser.components">
            <summary>
            Variable del diseñador requerida.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcTextureBrowser.Dispose(System.Boolean)">
            <summary>
            Limpiar los recursos que se estén utilizando.
            </summary>
            <param name="disposing">true si los recursos administrados se deben eliminar; false en caso contrario, false.</param>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcTextureBrowser.InitializeComponent">
            <summary>
            Método necesario para admitir el Diseñador. No se puede modificar
            el contenido del método con el editor de código.
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcTextureModifier">
            <summary>
                Modificador para elegir una textura
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Modifier.TgcTextureModifier.getImage(System.String)">
            <summary>
                Obtener la imagen pedida o devolver null
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcVertex2fModifier">
            <summary>
                Modificador para valores floats (X,Y) o (U,V) de un vertice
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Modifier.TgcVertex3fModifier">
            <summary>
                Modificador para valores floats (X,Y,Z) de un vertice
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcLanBrowser.getNetworkComputers">
            <summary>
                Devuelve una lista de Nombres de dominio de las PCs de la red local
                que sean del tipo SV_TYPE_WORKSTATION y SV_TYPE_SERVER
                Uses the DllImport : NetServerEnum with all its required parameters
                (see http://msdn.microsoft.com/library/default.asp?url=/library/en-us/netmgmt/netmgmt/netserverenum.asp
                for full details or method signature) to retrieve a list of domain SV_TYPE_WORKSTATION and SV_TYPE_SERVER PC's
            </summary>
            <returns>Lista de Domains encontrados</returns>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcNetworkingModifier">
            <summary>
                Modifier para Networking.
                Permite crear servidores y conectarse a estos como cliente, mediante conexiones TCP/IP utilizando DirectPlay.
                Abstrae todo el manejo interno de DirectPlay para el manejo de conexiones.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.#ctor(System.String,System.String,System.String,System.Int32)">
            <summary>
                Crea el modificador de Networking
            </summary>
            <param name="varName">Identificador del modifier</param>
            <param name="serverName">Nombre default que va a usar el servidor</param>
            <param name="clientName">Nombre default que va a usar cada cliente</param>
            <param name="port">Puerto en el cual se va a crear y buscar conexiones</param>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcNetworkingModifier.AvaliableServers">
            <summary>
                Servidores disponibles
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcNetworkingModifier.Server">
            <summary>
                Servidor de la conexion.
                Solo estara Online si creó una nueva sesion de servidor en la aplicacion
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcNetworkingModifier.Client">
            <summary>
                Cliente de la conexion.
                Solo estara Conectado si se especificó desde la aplicacion a que servidor conectarse
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcNetworkingModifier.NewClientsCount">
            <summary>
                Cantidad de clientes nuevos que se han conectado recientemente y que aún
                están pendientes de lectura.
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcNetworkingModifier.DisconnectedClientsCount">
            <summary>
                Cantidad de clientes que se han desconectado recientemente y que aún
                están pendientes de lectura.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.createServer(System.String)">
            <summary>
                Intenta crear un nuevo servidor
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.updateNetwork">
            <summary>
                Actualiza todo el estado de la red, tanto para clientes como servidores.
                Debe llamarse en cada cuadro de Render, antes de comenzar a analizar
                los mensajes de la red.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.nextNewClient">
            <summary>
                Devuelve el próximo cliente que se ha conectado recientemente y que aún
                está pendiente de lectura.
                Cada vez que se llama al método se consume el aviso y ese cliente ya no se
                considera más pendietne de lectura.
            </summary>
            <returns>Información del cliente recientemente conectado</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.nextDisconnectedClient">
            <summary>
                Devuelve el próximo cliente que se ha desconectado recientemente y que aún
                está pendiente de lectura.
                Cada vez que se llama al método se consume el aviso y ese cliente ya no se
                considera más pendietne de lectura.
            </summary>
            <returns>Información del cliente recientemente desconectado</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.closeServer">
            <summary>
                Cerrar el server
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.deleteClient(System.Int32)">
            <summary>
                Eliminar un cliente por parte del server
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.searchServers">
            <summary>
                Buscar servers el puerto especificado
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.connectToServer(System.Int32,System.String)">
            <summary>
                Conectarse a un server en particular
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.disconnectFromServer">
            <summary>
                Desconectar el cliente del server
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifier.dispose">
            <summary>
                Limpia todas las conexiones que se hayan abierto
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcNetworkingModifierClientsDialog">
            <summary>
                Ventana para ver los clientes conectados al server
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierClientsDialog.onServerCreated">
            <summary>
                Se creo un nuevo server, limpiar todo lo anterior
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierClientsDialog.dataGridViewConnectedClients_RowEnter(System.Object,System.Windows.Forms.DataGridViewCellEventArgs)">
            <summary>
                Se elige un cliente de la tabla
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierClientsDialog.addClient(TGC.Core.UserControls.Networking.TgcSocketClientInfo)">
            <summary>
                Agregar un cliente a la lista de conectados
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierClientsDialog.onClientDisconnected(TGC.Core.UserControls.Networking.TgcSocketClientInfo)">
            <summary>
                Eliminar un cliente conectado de la lista que se acaba de desconectar
            </summary>
        </member>
        <member name="F:TGC.Core.UserControls.Networking.TgcNetworkingModifierClientsDialog.components">
            <summary>
            Variable del diseñador requerida.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierClientsDialog.Dispose(System.Boolean)">
            <summary>
            Limpiar los recursos que se estén utilizando.
            </summary>
            <param name="disposing">true si los recursos administrados se deben eliminar; false en caso contrario, false.</param>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierClientsDialog.InitializeComponent">
            <summary>
            Método necesario para admitir el Diseñador. No se puede modificar
            el contenido del método con el editor de código.
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl">
            <summary>
                Control grafico de Modifier para Networking
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.AvaliableServers">
            <summary>
                Servidores disponibles
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.buttonCreateServer_Click(System.Object,System.EventArgs)">
            <summary>
                Crear nuevo server
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.getServerName">
            <summary>
                Obtener nombre de server
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.addClient(TGC.Core.UserControls.Networking.TgcSocketClientInfo)">
            <summary>
                Agregar un cliente a la lista de conectados
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.buttonConnectedClients_Click(System.Object,System.EventArgs)">
            <summary>
                Mostrar ventana de clientes conectados
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.onClientDisconnected(TGC.Core.UserControls.Networking.TgcSocketClientInfo)">
            <summary>
                Eliminar un cliente conectado de la lista que se acaba de desconectar
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.buttonCloseServer_Click(System.Object,System.EventArgs)">
            <summary>
                Cerrar el servidor
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.deleteClient(System.Int32)">
            <summary>
                Eliminar por decision del server un cliente conectado
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.buttonJoinServer_Click(System.Object,System.EventArgs)">
            <summary>
                Abrir la ventana para buscar servidores
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.searchServers">
            <summary>
                Buscar servidores
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.addServerToList(TGC.Core.UserControls.Networking.TgcSocketClient.TgcAvaliableServer)">
            <summary>
                Agregar server encontrado a la lista de servers disponibles
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.connectToServer(System.Int32,System.String)">
            <summary>
                Conectarse al server elegido
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.clientConnectedToServer(TGC.Core.UserControls.Networking.TgcSocketServerInfo,System.Int32)">
            <summary>
                Cuando el cliente se conecto finalmente con el server
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.buttonDisconnect_Click(System.Object,System.EventArgs)">
            <summary>
                Desconectarse del server
            </summary>
        </member>
        <member name="F:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.components">
            <summary> 
            Variable del diseñador requerida.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.Dispose(System.Boolean)">
            <summary> 
            Limpiar los recursos que se estén utilizando.
            </summary>
            <param name="disposing">true si los recursos administrados se deben eliminar; false en caso contrario, false.</param>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierControl.InitializeComponent">
            <summary> 
            Método necesario para admitir el Diseñador. No se puede modificar
            el contenido del método con el editor de código.
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog">
            <summary>
                Ventana para buscar servidores
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog.prepareDialog">
            <summary>
                Limpiar las cosas al principio antes de mostrar
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog.buttonRefreshServers_Click(System.Object,System.EventArgs)">
            <summary>
                Buscar servidores
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog.addServerToList(TGC.Core.UserControls.Networking.TgcSocketClient.TgcAvaliableServer)">
            <summary>
                Se encontro un server
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog.dataGridViewAvaliableServers_RowEnter(System.Object,System.Windows.Forms.DataGridViewCellEventArgs)">
            <summary>
                Eligieron un server de la lista
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog.buttonConnect_Click(System.Object,System.EventArgs)">
            <summary>
                Conectarse a un server
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog.getClientName">
            <summary>
                Obtener nombre de cliente
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog.buttonAddServer_Click(System.Object,System.EventArgs)">
            <summary>
                Agregar un server a mano
            </summary>
        </member>
        <member name="F:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog.components">
            <summary>
            Variable del diseñador requerida.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog.Dispose(System.Boolean)">
            <summary>
            Limpiar los recursos que se estén utilizando.
            </summary>
            <param name="disposing">true si los recursos administrados se deben eliminar; false en caso contrario, false.</param>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcNetworkingModifierServersDialog.InitializeComponent">
            <summary>
            Método necesario para admitir el Diseñador. No se puede modificar
            el contenido del método con el editor de código.
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClient.ClientName">
            <summary>
                Nombre del cliente
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClient.Status">
            <summary>
                Estado del cliente
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClient.PlayerId">
            <summary>
                ID que identifica unívocamente al cliente
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClient.ServerInfo">
            <summary>
                Información del server al cual se conectó
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClient.Online">
            <summary>
                Indica si el cliente está online
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketClient.connect(System.String,System.Int32)">
            <summary>
                Se conecta a un nuevo servidor. Pero todavía no lo toma como definitivo hasta
                que no se hace la selección final.
            </summary>
            <param name="ip">IP del server</param>
            <param name="port">Puerto del server</param>
            <returns>True si todo salio bien</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketClient.disconnectClient">
            <summary>
                Desconecta el cliente
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketClient.updateNetwork">
            <summary>
                Recibe todos los mensajes pendientes de la red y actualiza todos los estados
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketClient.send(TGC.Core.UserControls.Networking.TgcSocketSendMsg)">
            <summary>
                Enviar un mensaje al server
            </summary>
            <param name="msg">Mensaje a enviar</param>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketClient.getReceiveMessage">
            <summary>
                Recibir mensaje del servidor
            </summary>
            <returns>True si todo salio bien, False en caso de problemas en la conexión</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketClient.getServerInitialInfo">
            <summary>
                Recibir informacion inicial del server
            </summary>
            <returns>True si todo salio bien</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketClient.doHandShake">
            <summary>
                Empezar el handshake con el server
            </summary>
            <returns>True si todo salio bien</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketClient.findLanServers(System.Int32)">
            <summary>
                Buscar todos los servers disponibles de la LAN bajo el puerto especificado
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcSocketClient.TgcAvaliableServer">
            <summary>
                Representa un servidor de la LAN disponible para conectarse
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClient.TgcAvaliableServer.HostName">
            <summary>
                HostName
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClient.TgcAvaliableServer.Ip">
            <summary>
                IP
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcSocketClientInfo.ClientStatus">
            <summary>
                Estados del cliente respecto de como los ve el servidor
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClientInfo.Socket">
            <summary>
                Socket del cliente abierto por el server
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClientInfo.Address">
            <summary>
                Dirección IP del cliente
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClientInfo.Name">
            <summary>
                Nombre del cliente
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClientInfo.PlayerId">
            <summary>
                ID que identifica al cliente unívocamente
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClientInfo.Status">
            <summary>
                Estado del cliente respecto de como lo ve el servidor
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketMessages.sendMessage(System.Net.Sockets.Socket,TGC.Core.UserControls.Networking.TgcSocketSendMsg,TGC.Core.UserControls.Networking.TgcSocketMessageHeader.MsgType)">
            <summary>
                Enviar un mensaje de TGC por un socket
            </summary>
            <param name="socket">Socket por el cual enviar</param>
            <param name="msg">Mensaje a enviar</param>
            <param name="msgType">Tipo de mensaje a enviar</param>
            <returns>True si lo pudo hacer bien</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketMessages.receiveMessage(System.Net.Sockets.Socket,TGC.Core.UserControls.Networking.TgcSocketMessageHeader.MsgType)">
            <summary>
                Recibe un mensaje de TGC por un socket
            </summary>
            <param name="socket">Socket del cual recibir</param>
            <param name="msgType">Tipo de mensaje esperado</param>
            <returns>Mensaje recibido o null si recibió mal</returns>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcSocketMessageHeader">
            <summary>
                Tipos de header de los mensajes enviados
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcSocketInitialInfoClient">
            <summary>
                Información inicial enviada por el Cliente al Servidor
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcSocketSendMsg">
            <summary>
                Mensaje para enviar información
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketSendMsg.write(System.Object)">
            <summary>
                Agregar un nuevo objeto/valor al mensaje
            </summary>
            <param name="value">objeto a agregar</param>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcSocketRecvMsg">
            <summary>
                Mensaje para recibir información
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketRecvMsg.readNext">
            <summary>
                Leer un objeto del mensaje y avanza a la siguiente posición
            </summary>
            <returns>Objeto leido</returns>
        </member>
        <member name="T:TGC.Core.UserControls.Networking.TgcSocketClientRecvMesg">
            <summary>
                Mensajes enviados por un cliente y recibidos por el server
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClientRecvMesg.Msg">
            <summary>
                Mensaje recibido
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketClientRecvMesg.PlayerId">
            <summary>
                ID del cliente que lo envio
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketServer.Clients">
            <summary>
                Clientes conectados al servidor.
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketServer.ServerName">
            <summary>
                Nombre del servidor
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketServer.Online">
            <summary>
                Indica si el servidor está online
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketServer.ServerAddress">
            <summary>
                IP del servidor
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketServer.NewClientsCount">
            <summary>
                Cantidad de clientes nuevos que se han conectado recientemente y que aún
                están pendientes de lectura.
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketServer.ReceivedMessagesCount">
            <summary>
                Cantidad de nuevos mensajes recibidos pendientes de lectura
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketServer.DisconnectedClientsCount">
            <summary>
                Cantidad de clientes que se han desconectado recientemente y que aún
                están pendientes de lectura.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.getHostAddress">
            <summary>
                Devuelve la IP de la PC local
            </summary>
            <returns>IP local</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.initializeServer(System.String)">
            <summary>
                Inicia una nueva conexion TCP/IP con el nombre de sesion especificado
                en la IP local y el puerto default
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.initializeServer(System.String,System.Int32)">
            <summary>
                Inicia una nueva conexion TCP/IP con el nombre de sesion especificado
                en la IP local y el puerto especificado
            </summary>
            <returns>True si todo salio bien</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.disconnectServer">
            <summary>
                Desconecta el servidor
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.updateNetwork">
            <summary>
                Recibe todos los mensajes pendientes de la red y actualiza todos los estados
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.getClientInfo(System.Int32)">
            <summary>
                Busca la información de un cliente en base a su playerId
            </summary>
            <returns>Null si no lo encuentra</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.sendToClient(System.Int32,TGC.Core.UserControls.Networking.TgcSocketSendMsg)">
            <summary>
                Envia un mensaje a un cliente particular
            </summary>
            <param name="playerId">ID del cliente</param>
            <param name="msg">Mensaje a enviar</param>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.sendToAll(TGC.Core.UserControls.Networking.TgcSocketSendMsg)">
            <summary>
                Envia un mensaje a todos los clientes conectados al servidor
            </summary>
            <param name="msg">Mensaje a enviar</param>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.sendToAllExceptOne(System.Int32,TGC.Core.UserControls.Networking.TgcSocketSendMsg)">
            <summary>
                Envia un mensaje a todos los clientes conectados al servidor, a excepción
                de uno.
            </summary>
            <param name="playerIdException">ID de cliente al que no se le va a mandar el mensaje</param>
            <param name="msg">Mensaje a enviar</param>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.sendToClient(TGC.Core.UserControls.Networking.TgcSocketClientInfo,TGC.Core.UserControls.Networking.TgcSocketSendMsg)">
            <summary>
                Enviar mensaje a cliente, solo si esta conectado
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.nextNewClient">
            <summary>
                Devuelve el próximo cliente que se ha conectado recientemente y que aún
                está pendiente de lectura.
                Cada vez que se llama al método se consume el aviso y ese cliente ya no se
                considera más pendietne de lectura.
            </summary>
            <returns>Información del cliente recientemente conectado</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.nextReceivedMessage">
            <summary>
                Devuelve el próximo mensaje recibido y que aún está pendiente de lectura.
                Cada vez que se llama al método se consume el aviso y ese mensaje ya no se
                considera más pendietne de lectura.
            </summary>
            <returns>Mensaje recibido</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.nextDisconnectedClient">
            <summary>
                Devuelve el próximo cliente que se ha desconectado recientemente y que aún
                está pendiente de lectura.
                Cada vez que se llama al método se consume el aviso y ese cliente ya no se
                considera más pendietne de lectura.
            </summary>
            <returns>Información del cliente recientemente desconectado</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.getReceiveMessage(TGC.Core.UserControls.Networking.TgcSocketClientInfo,System.Net.Sockets.Socket)">
            <summary>
                Lee un mensaje ordinario recibido por el cliente
            </summary>
            <returns>True si todo salio bien</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.getClientOkResponse(TGC.Core.UserControls.Networking.TgcSocketClientInfo,System.Net.Sockets.Socket)">
            <summary>
                Recibir la confirmación final del cliente para empezar a recibir mensajes de la aplicación
            </summary>
            <returns>True si todo salio bien</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.getClientInitialInfo(TGC.Core.UserControls.Networking.TgcSocketClientInfo,System.Net.Sockets.Socket)">
            <summary>
                Recibir información inicial del cliente
            </summary>
            <returns>True si todo salio bien</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.doHandshake(TGC.Core.UserControls.Networking.TgcSocketClientInfo,System.Net.Sockets.Socket)">
            <summary>
                Hacer Handshake con el cliente para ver si es un cliente correcto
            </summary>
            <returns>True si todo salio bien</returns>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.acceptNewClients">
            <summary>
                Atender nuevas conexiones de clientes
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.Networking.TgcSocketServer.disconnectClient(System.Int32)">
            <summary>
                Desconectar a un cliente particular  del servidor
            </summary>
            <param name="playerId">ID del cliente a desconectar</param>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketServerInfo.Address">
            <summary>
                Dirección IP del cliente
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketServerInfo.Port">
            <summary>
                Puerto del servidor
            </summary>
        </member>
        <member name="P:TGC.Core.UserControls.Networking.TgcSocketServerInfo.Name">
            <summary>
                Nombre del cliente
            </summary>
        </member>
        <member name="T:TGC.Core.UserControls.TgcUserVars">
            <summary>
                Admnistrador de la tabla de User Vars.
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.TgcUserVars.ClearVars">
            <summary>
                Elimina todas las UserVars
            </summary>
        </member>
        <member name="M:TGC.Core.UserControls.TgcUserVars.addVar(System.String)">
            <summary>
                Agrega una nueva UserVar
            </summary>
            <param name="name">Identificador unico de la variable</param>
        </member>
        <member name="M:TGC.Core.UserControls.TgcUserVars.setValue(System.String,System.Object,System.Drawing.Color)">
            <summary>
                Carga el valor de una variable
            </summary>
            <param name="name">Identificador de la variable, cargado previamente</param>
            <param name="value">Valor a cargar</param>
            <param name="foreColor">Color de la letra</param>
        </member>
        <member name="M:TGC.Core.UserControls.TgcUserVars.setValue(System.String,System.Object)">
            <summary>
                Carga el valor de una variable
            </summary>
            <param name="name">Identificador de la variable, cargado previamente</param>
            <param name="value">Valor a cargar</param>
        </member>
        <member name="M:TGC.Core.UserControls.TgcUserVars.getValue(System.String)">
            <summary>
                Devuelve el valor de la variable especificada
            </summary>
            <param name="??">Identificador de la variable</param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.UserControls.TgcUserVars.addVar(System.String,System.Object)">
            <summary>
                Agrega una nueva variable junto con su valor
            </summary>
            <param name="name">Identificador unico de la variable</param>
            <param name="value">Valor a cargar</param>
        </member>
        <member name="T:TGC.Core.Utils.FastMath">
            <summary>
                Funciones matemáticas rápidas y optimizadas
            </summary>
        </member>
        <member name="F:TGC.Core.Utils.FastMath.PI">
            <summary>
                Representa la relación entre la longitud de la circunferencia de un círculo
                y su diámetro, especificada por la constante PI.
            </summary>
        </member>
        <member name="F:TGC.Core.Utils.FastMath.PI_HALF">
            <summary>
                PI / 2
            </summary>
        </member>
        <member name="F:TGC.Core.Utils.FastMath.TWO_PI">
            <summary>
                2 PI
            </summary>
        </member>
        <member name="F:TGC.Core.Utils.FastMath.QUARTER_PI">
            <summary>
                PI / 4
            </summary>
        </member>
        <member name="F:TGC.Core.Utils.FastMath.E">
            <summary>
                Representa la base logarítmica natural, especificada por la constante, e.
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Sin(System.Single)">
            <summary>
                Devuelve el seno del ángulo especificado.
                Utiliza valores precalculados con una precisión fija para obtener el resultado.
            </summary>
            <param name="x">Ángulo, medido en radianes.</param>
            <returns>Seno de x</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:TGC.Core.Utils.FastMath.Asin(System.Single)" -->
        <member name="M:TGC.Core.Utils.FastMath.Sinh(System.Single)">
            <summary>
                Devuelve el seno hiperbólico del ángulo especificado.
            </summary>
            <param name="x">Ángulo, medido en radianes.</param>
            <returns>Seno hiperbólico de x</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Cos(System.Single)">
            <summary>
                Devuelve el coseno del ángulo especificado.
                Utiliza valores precalculados con una precisión fija para obtener el resultado.
            </summary>
            <param name="x">Ángulo, medido en radianes.</param>
            <returns>Coseno de x</returns>
        </member>
        <!-- Badly formed XML comment ignored for member "M:TGC.Core.Utils.FastMath.Acos(System.Single)" -->
        <member name="M:TGC.Core.Utils.FastMath.Cosh(System.Single)">
            <summary>
                Devuelve el coseno hiperbólico del ángulo especificado.
            </summary>
            <param name="x">Ángulo, medido en radianes.</param>
            <returns>Coseno hiperbólico de x</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Tan(System.Single)">
            <summary>
                Devuelve la tangente del ángulo especificado.
                Utiliza valores precalculados con una precisión fija para obtener el resultado.
            </summary>
            <param name="x">Ángulo, medido en radianes.</param>
            <returns>Tangente de x</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Atan(System.Single)">
            <summary>
                Devuelve el ángulo cuya tangente corresponde al número especificado.
            </summary>
            <param name="x">Número que representa una tangente.</param>
            <returns>Arcotangente de x</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Atan2(System.Single,System.Single)">
            <summary>
                Devuelve el ángulo cuya tangente es el cociente de dos números especificados.
            </summary>
            <param name="y">Coordenada y de un punto.</param>
            <param name="x">Coordenada x de un punto.</param>
            <returns>Arcotangente</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Tanh(System.Single)">
            <summary>
                Devuelve la tangente hiperbólica del ángulo especificado.
            </summary>
            <param name="x">Ángulo, medido en radianes.</param>
            <returns>Tangente hiperbólica de x</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Sqrt(System.Single)">
            <summary>
                Devuelve la raíz cuadrada de un número especificado.
            </summary>
            <param name="x">Un número.</param>
            <returns>Raíz cuadrada</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.InvSqrt(System.Single)">
            <summary>
                Inversa de la raíz cuadrada de un número
            </summary>
            <param name="x">Un número.</param>
            <returns>Inversa de la raíz</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Ceiling(System.Single)">
            <summary>
                Devuelve el siguiente entero mayor o igual que el número decimal especificado.
            </summary>
            <param name="x">Número decimal.</param>
            <returns>El número entero más pequeño mayor o igual que x.</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Floor(System.Single)">
            <summary>
                Devuelve el siguiente entero menor o igual que el número de punto flotante
                de precisión doble especificado.
            </summary>
            <param name="x">Número decimal.</param>
            <returns>Número entero más grande menor o igual que x.</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Log(System.Single)">
            <summary>
                Devuelve el logaritmo natural (en base e) de un número especificado.
            </summary>
            <param name="x">Número cuyo logaritmo hay que calcular.</param>
            <returns>Logaritmo natural de x</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Log10(System.Single)">
            <summary>
                Devuelve el logaritmo en base 10 de un número especificado.
            </summary>
            <param name="x">Número cuyo logaritmo hay que calcular.</param>
            <returns>Logaritmo en base 10 de x</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.ToDeg(System.Single)">
            <summary>
                Convierte radianes en grados
            </summary>
            <param name="x">Valor en radianes</param>
            <returns>Valor en grados</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.ToRad(System.Single)">
            <summary>
                Convierte grados en radiantes
            </summary>
            <param name="x">Valor en grados</param>
            <returns>Valor en radianes</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Pow(System.Single,System.Single)">
            <summary>
                Devuelve un número especificado elevado a la potencia especificada.
            </summary>
            <param name="x">Número que especifica una potencia.</param>
            <param name="y">Número que se desea elevar a una potencia.</param>
            <returns>Número x elevado a la potencia y</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Pow2(System.Single)">
            <summary>
                Devuelve un número especificado elevado al cuadrado.
            </summary>
            <param name="x">Número que especifica una potencia.</param>
            <returns>Número x elevado al cuadrado</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Pow(System.Int32,System.Int32)">
            <summary>
                Devuelve un número especificado elevado a la potencia especificada, como Integer.
            </summary>
            <param name="x">Número que especifica una potencia.</param>
            <param name="y">Número que se desea elevar a una potencia.</param>
            <returns>Número x elevado a la potencia y</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.EpsilonEquals(System.Single,System.Single)">
            <summary>
                Compara la igualdad de dos números teniendo en cuenta una diferencia Epsilon
            </summary>
            <param name="v1">Número 1</param>
            <param name="v2">Número 2</param>
            <returns>Resultado de la comparación</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Abs(System.Single)">
            <summary>
                Devuelve el valor absoluto de un número
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Min(System.Single,System.Single)">
            <summary>
                Devuelve el valor mínimo entre v1 y v2
            </summary>
            <param name="v1">Valor 1</param>
            <param name="v2">Valor 2</param>
            <returns>Mínimo valor</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Min(System.Int32,System.Int32)">
            <summary>
                Devuelve el valor mínimo entre v1 y v2
            </summary>
            <param name="v1">Valor 1</param>
            <param name="v2">Valor 2</param>
            <returns>Mínimo valor</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Max(System.Single,System.Single)">
            <summary>
                Devuelve el valor máximo entre v1 y v2
            </summary>
            <param name="v1">Valor 1</param>
            <param name="v2">Valor 2</param>
            <returns>Máximo valor</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Max(System.Int32,System.Int32)">
            <summary>
                Devuelve el valor máximo entre v1 y v2
            </summary>
            <param name="v1">Valor 1</param>
            <param name="v2">Valor 2</param>
            <returns>Máximo valor</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Clamp(System.Single,System.Single,System.Single)">
            <summary>
                Clampear x al intervalo [min, max]
            </summary>
            <param name="x">Valor a hacer clamp</param>
            <param name="min">Maximo inclusive</param>
            <param name="max">Minimo inclusive</param>
            <returns>Valor campleado</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Clamp(System.Int32,System.Int32,System.Int32)">
            <summary>
                Clampear x al intervalo [min, max]
            </summary>
            <param name="x">Valor a hacer clamp</param>
            <param name="min">Maximo inclusive</param>
            <param name="max">Minimo inclusive</param>
            <returns>Valor campleado</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.Exp(System.Single)">
            <summary>
                Devuelve E^n
            </summary>
            <param name="n">Exponente</param>
            <returns>E elevado a la n</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.GaussianDistribution(System.Single,System.Single,System.Single)">
            <summary>
                Calculo de funcion de Gauss
            </summary>
            <param name="x">valor de X</param>
            <param name="y">valor de Y</param>
            <param name="rho">standard deviation</param>
            <returns>valor de la funcion de distribucion de Gauss</returns>
        </member>
        <member name="M:TGC.Core.Utils.FastMath.GaussianDistribution(System.Single,System.Single)">
            <summary>
                Calculo de funcion de Gauss
            </summary>
            <param name="x">valor de X</param>
            <param name="rho">standard deviation</param>
            <returns>valor de la funcion de distribucion de Gauss</returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseFloat(System.String)">
            <summary>
                Parsea un float, con un NumberFormatInfo independiente de la pc
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseInt(System.String)">
            <summary>
                Parsea un int
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseFloat3Array(System.String)">
            <summary>
                Parsea el string "[-8.00202,-6.87125,0]" y devuelve un array de 3 floats.
                Sin invertir nada
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseFloat3ArrayAdapted(System.String)">
            <summary>
                Parsea el string "[-8.00202,-6.87125,0]" y devuelve un array de 3 floats.
                Invierte las coordenadas (x,y,z) a (x,z,y), de formato 3DsMAX a DirectX
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseInt3Array(System.String)">
            <summary>
                Parsea el string "[4,2,1]" y devuelve un array de 3 int.
                Sin invertir nada
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseInt3ArrayAdapted(System.String)">
            <summary>
                Parsea el string "[4,2,1]" y devuelve un array de 3 int.
                Invierte las coordenadas (x,y,z) a (x,z,y), de formato 3DsMAX a DirectX
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseFloat2Array(System.String)">
            <summary>
                Parsea el string "[-8.00202,-6.87125]" y devuelve un array de 2 floats.
                Sin invertir nada
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseFloat2ArrayAdapted(System.String)">
            <summary>
                Parsea el string "[-8.00202,-6.87125]" y devuelve un array de 2 floats.
                Invierte las coordenadas (x,y) a (y,x), de formato 3DsMAX a DirectX
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseInt2Array(System.String)">
            <summary>
                Parsea el string "[4,2]" y devuelve un array de 2 int.
                Invierte las coordenadas (x,y,z) a (x,z,y), de formato 3DsMAX a DirectX
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseInt2ArrayAdapted(System.String)">
            <summary>
                Parsea el string "[4,2]" y devuelve un array de 2 int.
                Sin invertir nada
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseFloat4Array(System.String)">
            <summary>
                Parsea el string "[-8.00202,-6.87125,0,0.211]" y devuelve un array de 4 floats.
                Sin invertir nada
            </summary>
            <param name="text"></param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.divFloatArrayValues(System.Single[]@,System.Single)">
            <summary>
                Dividir todo el array de floats por el valor especificado
            </summary>
            <param name="array"></param>
            <param name="divValue"></param>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.sumFloatArrayValues(System.Single[]@,System.Single)">
            <summary>
                Suma a todo el array de floats el valor especificado
            </summary>
            <param name="array"></param>
            <param name="sumValue"></param>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.sumIntArrayValues(System.Int32[]@,System.Int32)">
            <summary>
                Suma a todo el array de ints el valor especificado
            </summary>
            <param name="array"></param>
            <param name="sumValue"></param>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseIntStream(System.String,System.Int32)">
            <summary>
                Parsea un flujo continuo de ints de la forma: 15 10 16 11 16 10 16 11 17 12 17 11 17 12...
            </summary>
            <param name="text">flujo de ints</param>
            <param name="count">cantidad de valores dentro del flujo</param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.parseFloatStream(System.String,System.Int32)">
            <summary>
                Parsea un flujo continuo de floats de la forma: -74.1818 0.0 1.01613 -49.6512 0.0 1.01613...
            </summary>
            <param name="text">flujo de floats</param>
            <param name="count">cantidad de valores dentro del flujo</param>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printFloat(System.Single)">
            <summary>
                Convierte un float a un string, con un NumberFormatInfo independiente de la pc
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printVector3(System.Single,System.Single,System.Single)">
            <summary>
                Imprime un Vector3 de la forma [150.0,150.0,150.0]
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printVector3(Microsoft.DirectX.Vector3)">
            <summary>
                Imprime un Vector3 de la forma [150.0,150.0,150.0]
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printVector3FromString(System.String,System.String,System.String)">
            <summary>
                Imprime un Vector3 de la forma [150.0,150.0,150.0], tomando valores string
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printVector2(System.Single,System.Single)">
            <summary>
                Imprime un Vector2 de la forma [150.0,150.0]
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printVector2(Microsoft.DirectX.Vector2)">
            <summary>
                Imprime un Vector2 de la forma [150.0,150.0]
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printVectorFromString(System.String,System.String)">
            <summary>
                Imprime un Vector2 de la forma [150.0,150.0], tomando valores string
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printQuaternion(Microsoft.DirectX.Quaternion)">
            <summary>
                Imprime un Quaternion de la forma [x, y, z, w]
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printFloat2Array(System.Single[])">
            <summary>
                Imprime un float[2] de la forma [150.0,150.0]
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printFloat3Array(System.Single[])">
            <summary>
                Imprime un float[3] de la forma [150.0,150.0,150.0]
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printFloat4Array(System.Single[])">
            <summary>
                Imprime un float[4] de la forma [150.0,150.0,150.0,255.0]
            </summary>
            <returns></returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printFloatStream(System.Single[])">
            <summary>
                Toma un array de floats y lo imprime en un string de la forma: -74.1818 0.0 1.01613 -49.6512 0.0 1.01613...
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.printIntStream(System.Int32[])">
            <summary>
                Toma un array de INT y lo imprime en un string de la forma: -74 -49 0 15 ...
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.vector3ToFloat3Array(Microsoft.DirectX.Vector3)">
            <summary>
                Convierte un Vector3 a un float[3]
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.vector3ToFloat4Array(Microsoft.DirectX.Vector3)">
            <summary>
                Convierte un Vector3 a un float[4] con w = 1
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.vector3ToVector4(Microsoft.DirectX.Vector3)">
            <summary>
                Convierte un Vector3 a un Vector4 con w = 1
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.vector2ToFloat2Array(Microsoft.DirectX.Vector2)">
            <summary>
                Convierte un Vector2 a un float[2]
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.quaternionToFloat4Array(Microsoft.DirectX.Quaternion)">
            <summary>
                Convierte un Quaternion a un float[4]
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.float3ArrayToVector3(System.Single[])">
            <summary>
                Convierte un float[3] a un Vector3
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.float4ArrayToQuaternion(System.Single[])">
            <summary>
                Convierte un float[4] a un Quaternion
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.float4ArrayToPlane(System.Single[])">
            <summary>
                Convierte un float[4] a un Plane
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.vector2ArrayToFloat2Array(Microsoft.DirectX.Vector2[])">
            <summary>
                Convierte un array de Vector2 a un array de float
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcParserUtils.ColorToVector4(System.Drawing.Color)">
            <summary>
                convierte un color base(255,255,255,255) a un Vector4(1f,1f,1f,1f).
            </summary>
            <param name="color"></param>
            <returns></returns>
        </member>
        <member name="T:TGC.Core.Utils.TgcVectorUtils">
            <summary>
                Herramientas de manipulación de vectores
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.TgcVectorUtils.lengthSq(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Longitud al cuadrado del segmento ab
            </summary>
            <param name="a">Punto inicial del segmento</param>
            <param name="b">Punto final del segmento</param>
            <returns>Longitud al cuadrado</returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcVectorUtils.mul(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Multiplicar dos vectores.
                Se multiplica cada componente
            </summary>
            <param name="v1">Vector 1</param>
            <param name="v2">Vector 2</param>
            <returns>Vector resultante</returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcVectorUtils.div(Microsoft.DirectX.Vector3,Microsoft.DirectX.Vector3)">
            <summary>
                Dividir dos vectores.
                Se divide cada componente
            </summary>
            <param name="v1">Vector 1</param>
            <param name="v2">Vector 2</param>
            <returns>Vector resultante</returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcVectorUtils.transform(Microsoft.DirectX.Vector3,Microsoft.DirectX.Matrix)">
            <summary>
                Multiplicar un Vector3 por una Matriz.
                Devuelve un Vector3 ignorando W.
            </summary>
            <param name="v">Vector</param>
            <param name="m">Matriz</param>
            <returns>Vector resultante, sin W</returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcVectorUtils.abs(Microsoft.DirectX.Vector3)">
            <summary>
                Aplica el valor absoluto a todos los componentes del vector
            </summary>
            <param name="v">Vector</param>
            <returns>Vector resultante</returns>
        </member>
        <member name="M:TGC.Core.Utils.TgcVectorUtils.min(Microsoft.DirectX.Vector3)">
            <summary>
                Devuelve el menor valor de los 3 componentes del vector
            </summary>
            <param name="v">Vector</param>
            <returns>Menor valor de los tres</returns>
        </member>
        <member name="T:TGC.Core.Utils.ValidationUtils">
            <summary>
                Herramientas de validacion valores
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.ValidationUtils.validateRequired(System.String)">
            <summary>
                Valida que el texto haya sido cargado
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.ValidationUtils.validateSpaces(System.String)">
            <summary>
                Valida que el texto no tenga espacios
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.ValidationUtils.validateInt(System.String)">
            <summary>
                Valida que el texto recibido sea un int valido
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.ValidationUtils.validatePossitiveInt(System.String)">
            <summary>
                Valida que el texto recibido sea un int valido, mayor o igual a cero
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.ValidationUtils.validateFloat(System.String)">
            <summary>
                Valida que el texto recibido sea un float valido
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.ValidationUtils.validatePossitiveFloat(System.String)">
            <summary>
                Valida que el texto recibido sea un float valido mayor o igual a cero
            </summary>
        </member>
        <member name="M:TGC.Core.Utils.ValidationUtils.validateFloatRange(System.String,System.Single,System.Single)">
            <summary>
                Valida que el texto recibido sea un float valido, dentro del rango [min, max], ambos
                inclusive
            </summary>
        </member>
    </members>
</doc>
